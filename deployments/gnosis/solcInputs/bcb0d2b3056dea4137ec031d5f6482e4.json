{
  "language": "Solidity",
  "sources": {
    "contracts/DecimalHelpers.sol": {
      "content": "pragma solidity ^0.8.16;\n\n\ncontract DecimalsHelpers {\n    function decimalString(uint256 number, uint8 decimals, bool isPercent) internal pure returns(string memory){\n        if(number == 0){\n            return isPercent ? \"0%\" : \"0\";\n        }\n        \n        uint8 percentBufferOffset = isPercent ? 1 : 0;\n        uint256 tenPowDecimals = 10 ** decimals;\n\n        uint256 temp = number;\n        uint8 digits;\n        uint8 numSigfigs;\n        while (temp != 0) {\n            if (numSigfigs > 0) {\n                // count all digits preceding least significant figure\n                numSigfigs++;\n            } else if (temp % 10 != 0) {\n                numSigfigs++;\n            }\n            digits++;\n            temp /= 10;\n        }\n\n        DecimalStringParams memory params;\n        params.isPercent = isPercent;\n        if((digits - numSigfigs) >= decimals) {\n            // no decimals, ensure we preserve all trailing zeros\n            params.sigfigs = number / tenPowDecimals;\n            params.sigfigIndex = digits - decimals;\n            params.bufferLength = params.sigfigIndex + percentBufferOffset;\n        } else {\n            // chop all trailing zeros for numbers with decimals\n            params.sigfigs = number / (10 ** (digits - numSigfigs));\n            if(tenPowDecimals > number){\n                // number is less than one\n                // in this case, there may be leading zeros after the decimal place \n                // that need to be added\n\n                // offset leading zeros by two to account for leading '0.'\n                params.zerosStartIndex = 2;\n                params.zerosEndIndex = decimals - digits + 2;\n                params.sigfigIndex = numSigfigs + params.zerosEndIndex;\n                params.bufferLength = params.sigfigIndex + percentBufferOffset;\n                params.isLessThanOne = true;\n            } else {\n                // In this case, there are digits before and\n                // after the decimal place\n                params.sigfigIndex = numSigfigs + 1;\n                params.decimalIndex = digits - decimals + 1;\n            }\n        }\n        params.bufferLength = params.sigfigIndex + percentBufferOffset;\n        return generateDecimalString(params);\n    }\n\n    // With modifications, From https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/NFTDescriptor.sol#L189-L231\n\n    struct DecimalStringParams {\n        // significant figures of decimal\n        uint256 sigfigs;\n        // length of decimal string\n        uint8 bufferLength;\n        // ending index for significant figures (funtion works backwards when copying sigfigs)\n        uint8 sigfigIndex;\n        // index of decimal place (0 if no decimal)\n        uint8 decimalIndex;\n        // start index for trailing/leading 0's for very small/large numbers\n        uint8 zerosStartIndex;\n        // end index for trailing/leading 0's for very small/large numbers\n        uint8 zerosEndIndex;\n        // true if decimal number is less than one\n        bool isLessThanOne;\n        // true if string should include \"%\"\n        bool isPercent;\n    }\n\n    function generateDecimalString(DecimalStringParams memory params) private pure returns (string memory) {\n        bytes memory buffer = new bytes(params.bufferLength);\n        if (params.isPercent) {\n            buffer[buffer.length - 1] = '%';\n        }\n        if (params.isLessThanOne) {\n            buffer[0] = '0';\n            buffer[1] = '.';\n        }\n\n        // add leading/trailing 0's\n        for (uint256 zerosCursor = params.zerosStartIndex; zerosCursor < params.zerosEndIndex; zerosCursor++) {\n            buffer[zerosCursor] = bytes1(uint8(48));\n        }\n        // add sigfigs\n        while (params.sigfigs > 0) {\n            if (params.decimalIndex > 0 && params.sigfigIndex == params.decimalIndex) {\n                buffer[--params.sigfigIndex] = '.';\n            }\n            buffer[--params.sigfigIndex] = bytes1(uint8(uint256(48) + (params.sigfigs % 10)));\n            params.sigfigs /= 10;\n        }\n        return string(buffer);\n    }\n}"
    },
    "contracts/EnsoShortcutsHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @dev SignedMathHelpers contract is recommended to use only in Shortcuts passed to EnsoWallet.\n *\n * This contract functions allow to dynamically get the data during Shortcut transaction execution\n * that usually would be read between transactions\n */\ncontract EnsoShortcutsHelpers {\n    uint256 public constant VERSION = 2;\n\n    /**\n     * @dev Returns the ether balance of given `balanceAdderess`.\n     */\n    function getBalance(address balanceAddress) external view returns (uint256 balance) {\n        return address(balanceAddress).balance;\n    }\n\n    /**\n     * @dev Returns the current block timestamp.\n     */\n    function getBlockTimestamp() external view returns (uint256 timestamp) {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Returns a value depending on a truth condition\n     */\n    function toggle(bool condition, uint256 a, uint256 b) external pure returns (uint256) {\n        if (condition) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    /**\n     * @dev Returns the inverse bool\n     */\n    function not(bool condition) external pure returns (bool) {\n        return !condition;\n    }\n\n    /**\n     * @dev Returns bool for a == b\n     */\n    function isEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return a == b;\n    }\n\n    /**\n     * @dev Returns bool for a < b\n     */\n    function isLessThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a < b;\n    }\n\n    /**\n     * @dev Returns bool for a <= b\n     */\n    function isEqualOrLessThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a <= b;\n    }\n\n    /**\n     * @dev Returns bool for a > b\n     */\n    function isGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a > b;\n    }\n\n    /**\n     * @dev Returns bool for a >= b\n     */\n    function isEqualOrGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a >= b;\n    }\n\n    /**\n     * @dev Returns bool for a == b\n     */\n    function isAddressEqual(address a, address b) external pure returns (bool) {\n        return a == b;\n    }\n\n    /**\n     * @dev Returns `input` bytes as string.\n     */\n    function bytesToString(bytes calldata input) external pure returns (string memory) {\n        return string(abi.encodePacked(input));\n    }\n\n    /**\n     * @dev Returns `input` bytes as uint256.\n     */\n    function bytesToUint256(bytes calldata input) external pure returns (uint256) {\n        require(input.length == 32, \"EnsoShortcutsHelpers: input length is not 32 bytes\");\n        return uint256(bytes32(input));\n    }\n\n    /**\n     * @dev Returns `input` bytes as bytes32.\n     */\n    function bytesToBytes32(bytes calldata input) external pure returns (bytes32) {\n        return bytes32(input);\n    }\n\n    /**\n     * @dev Returns `input` bytes32 as uint256.\n     */\n    function bytes32ToUint256(bytes32 input) external pure returns (uint256) {\n        return uint256(input);\n    }\n\n    /**\n     * @dev Returns `input` bytes32 as address.\n     */\n    function bytes32ToAddress(bytes32 input) external pure returns (address) {\n        return address(uint160(uint256(input)));\n    }\n\n    /**\n     * @dev Returns uint256 `value` as int256.\n     */\n    function uint256ToInt256(uint256 value) public pure returns (int256) {\n        require(value <= uint256(type(int256).max), \"Value does not fit in an int256\");\n        return int256(value);\n    }\n\n    /**\n     * @dev Returns int256 `value` as uint256.\n     */\n    function int256ToUint256(int256 value) public pure returns (uint256) {\n        require(value >= 0, \"Value must be positive\");\n        return uint256(value);\n    }\n}\n"
    },
    "contracts/MathHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @dev MathHelpers contract is recommended to use only in Shortcuts passed to EnsoWallet\n *\n * Based on OpenZepplin Contracts v4.7.3:\n * - utils/math/Math.sol (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/Math.sol)\n * - utils/math/SafeMath.sol (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol)\n */\ncontract MathHelpers {\n    uint256 public constant VERSION = 1;\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) external pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) external pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) external pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) external pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) external pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) external pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) external pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) external pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the results a math operation if a condition is met. Otherwise returns the 'a' value without any modification.\n     */\n    function conditional(bool condition, bytes4 method, uint256 a, uint256 b) external view returns (uint256) {\n        if (condition) {\n            (bool success, bytes memory n) = address(this).staticcall(abi.encodeWithSelector(method, a, b));\n            if (success) return abi.decode(n, (uint256));\n        }\n        return a;\n    }\n}\n"
    },
    "contracts/PercentageMathHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @dev PercentageMath contract is recommended to use only in Shortcuts passed to EnsoWallet\n *\n * Forked from Aave PercentageMath library:\n * - protocol-v2/contracts/protocol/libraries/math/PercentageMath.sol (https://github.com/aave/protocol-v2/blob/ice/mainnet-deployment-03-12-2020/contracts/protocol/libraries/math/PercentageMath.sol)\n */\n\ncontract PercentageMathHelpers {\n  uint256 public constant VERSION = 1;\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\n\n  /**\n   * @dev Executes a percentage multiplication\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return The percentage of value\n   **/\n\n  function percentMul(uint256 value, uint256 percentage) external pure returns (uint256) {\n    if (value == 0 || percentage == 0) {\n      return 0;\n    }\n\n    require(\n      value <= (type(uint256).max - HALF_PERCENT) / percentage, \"multiplication overflow\"\n    );\n\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\n  }\n\n  /**\n   * @dev Executes a percentage division\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return The value divided the percentage\n   **/\n  function percentDiv(uint256 value, uint256 percentage) external pure returns (uint256) {\n    require(percentage != 0, \"Division by 0\");\n    uint256 halfPercentage = percentage / 2;\n\n    require(\n      value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR, \"multiplication overflow\"\n    );\n\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\n  }\n}\n"
    },
    "contracts/SignedMathHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @dev SignedMathHelpers contract is recommended to use only in Shortcuts passed to EnsoWallet\n *\n * Based on OpenZepplin Contracts 4.7.3:\n * - utils/math/SignedMath.sol (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SignedMath.sol)\n * - utils/math/SignedSafeMath.sol (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SignedSafeMath.sol)\n */\ncontract SignedMathHelpers {\n    uint256 public constant VERSION = 1;\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) external pure returns (int256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * underflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) external pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) external pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) external pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) external pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) external pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) external pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) external pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n\n    /**\n     * @dev Returns the results a math operation if a condition is met. Otherwise returns the 'a' value without any modification.\n     */\n    function conditional(bool condition, bytes4 method, int256 a, int256 b) external view returns (int256) {\n        if (condition) {\n            (bool success, bytes memory n) = address(this).staticcall(abi.encodeWithSelector(method, a, b));\n            if (success) return abi.decode(n, (int256));\n        }\n        return a;\n    }\n}\n"
    },
    "contracts/TupleHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @notice Helper contract to extract a variety of types from a tuple within the context of a weiroll script\n */\ncontract TupleHelpers {\n    /**\n     * @notice Extract a bytes32 encoded static type from a tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded tuple\n     * @param index The index of the value to be extracted\n     */\n    function extractElement(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        assembly {\n            // let offset := mul(add(index, 1), 32)\n            // return(add(tuple, offset), 32)\n            return(add(tuple, mul(add(index, 1), 32)), 32)\n        }\n    }\n\n    /**\n     * @notice Extract a bytes encoded dynamic type from a tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded tuple\n     * @param index The index of the string or bytes to be extracted\n     */\n    function extractDynamicElement(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        assembly {\n            let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            let length := mload(add(tuple, offset))\n            if gt(mod(length, 32), 0) {\n                length := mul(add(div(length, 32), 1), 32)\n            }\n            return(add(tuple, add(offset, 32)), length)\n        }\n    }\n\n    /**\n     * @notice Extract a bytes encoded tuple from another tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded parent tuple\n     * @param index The index of the tuple to be extracted\n     * @param isDynamicTypeFormat Boolean to define whether the child tuple is dynamically sized. If the child tuple contains bytes or string variables, set to \"true\"\n     */\n    function extractTuple(\n        bytes memory tuple,\n        uint256 index,\n        bool[] memory isDynamicTypeFormat\n    ) public pure returns (bytes32) {\n        uint256 offset;\n        uint256 length;\n        assembly {\n            offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n        }\n        for (uint256 i = 0; i < isDynamicTypeFormat.length; i++) {\n            length += 32;\n            if (isDynamicTypeFormat[i]) {\n                assembly {\n                    let paramOffset := add(offset, mload(add(tuple, add(offset, mul(i, 32)))))\n                    let paramLength := add(mload(add(tuple, paramOffset)), 32)\n                    if gt(mod(paramLength, 32), 0) {\n                        paramLength := mul(add(div(paramLength, 32), 1), 32)\n                    }\n                    length := add(length, paramLength)\n                }\n            }\n        }\n        assembly {\n            return(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)), length)\n        }\n    }\n\n    /**\n     * @notice Extract a bytes encoded static array from a tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded array\n     * @param index The index of the array to be extracted\n     */\n    function extractArray(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        assembly {\n            // let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            // let numberOfElements := mload(add(tuple, offset))\n            // return(add(tuple, add(offset, 32)), mul(numberOfElements, 32))\n            return(\n                add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)),\n                mul(mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32))), 32)\n            )\n        }\n    }\n\n    /**\n     * @notice Extract a bytes encoded dynamic array from a tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded tuple\n     * @param index The index of the dynamic array to be extracted\n     */\n    function extractDynamicArray(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        uint256 numberOfElements;\n        uint256 offset;\n        assembly {\n            offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            numberOfElements := mload(add(tuple, offset))\n            //numberOfElements := mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)))\n        }\n\n        uint256 length;\n        for (uint256 i = 1; i <= numberOfElements; i++) {\n            assembly {\n                let paramOffset := add(offset, mul(add(i, 1), 32))\n                let paramLength := mload(add(tuple, paramOffset))\n                if gt(mod(paramLength, 32), 0) {\n                    paramLength := mul(add(div(paramLength, 32), 1), 32)\n                }\n                length := add(length, paramLength)\n                //length := add(length, mload(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), mul(add(i, 1), 32)))))\n            }\n        }\n        assembly {\n            // return(add(tuple, add(offset, 32)), add(length, 32))\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)), add(length, 32))\n        }\n    }\n\n    /**\n     * @notice Extract a bytes encoded array of tuples from a tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded tuple\n     * @param index The index of the tuple array to be extracted\n     * @param isDynamicTypeFormat Boolean to define whether the tuples in the array are dynamically sized. If the array tuple contains bytes or string variables, set to \"true\"\n     */\n    function extractTupleArray(\n        bytes memory tuple,\n        uint256 index,\n        bool[] memory isDynamicTypeFormat\n    ) public pure returns (bytes32) {\n        uint256 numberOfElements;\n        assembly {\n            // let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            // numberOfElements := mload(add(tuple, offset))\n            numberOfElements := mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)))\n        }\n        uint256 length = numberOfElements * 32;\n        for (uint256 i = 1; i <= numberOfElements; i++) {\n            for (uint256 j = 0; j < isDynamicTypeFormat.length; j++) {\n                length += 32;\n                if (isDynamicTypeFormat[j]) {\n                    assembly {\n                        // let tupleOffset := add(offset,mload(add(tuple, add(offset, mul(i, 32)))))\n                        // let paramOffset := add(tupleOffset, mload(add(tuple, add(tupleOffset, mul(add(j,1), 32)))))\n                        // let paramLength := add(mload(add(tuple, paramOffset)),32)\n                        // length := add(length, paramLength)\n                        length := add(\n                            length,\n                            add(\n                                mload(\n                                    add(\n                                        tuple,\n                                        add(\n                                            add(\n                                                add(mload(add(tuple, mul(add(index, 1), 32))), 32),\n                                                mload(\n                                                    add(\n                                                        tuple,\n                                                        add(\n                                                            add(mload(add(tuple, mul(add(index, 1), 32))), 32),\n                                                            mul(i, 32)\n                                                        )\n                                                    )\n                                                )\n                                            ),\n                                            mload(\n                                                add(\n                                                    tuple,\n                                                    add(\n                                                        add(\n                                                            add(mload(add(tuple, mul(add(index, 1), 32))), 32),\n                                                            mload(\n                                                                add(\n                                                                    tuple,\n                                                                    add(\n                                                                        add(\n                                                                            mload(add(tuple, mul(add(index, 1), 32))),\n                                                                            32\n                                                                        ),\n                                                                        mul(i, 32)\n                                                                    )\n                                                                )\n                                                            )\n                                                        ),\n                                                        mul(add(j, 1), 32)\n                                                    )\n                                                )\n                                            )\n                                        )\n                                    )\n                                ),\n                                32\n                            )\n                        )\n                    }\n                }\n            }\n        }\n        assembly {\n            // return(add(tuple, add(offset,32)), length)\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)), length)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}