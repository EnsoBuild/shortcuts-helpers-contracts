{
  "address": "0x8e140cCe7b194a507960cc746E83dAf296B0CEF7",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "extractArray",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "extractDynamicArray",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "extractDynamicElement",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "extractElement",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bool[]",
          "name": "isDynamicTypeFormat",
          "type": "bool[]"
        }
      ],
      "name": "extractTuple",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bool[]",
          "name": "isDynamicTypeFormat",
          "type": "bool[]"
        }
      ],
      "name": "extractTupleArray",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xb41b1390f654717a703cd37472d3a062d31880cffa3a2533d756fb577165ce18",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xf754916D90B109AE8E405FD34064cF6Df23947eb",
    "contractAddress": null,
    "transactionIndex": 2,
    "gasUsed": "2075961",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x78df3497b5374fbdfc7d9ceb24d5f45cabaf6235bee2a802b3b892dcb3bd453a",
    "transactionHash": "0xb41b1390f654717a703cd37472d3a062d31880cffa3a2533d756fb577165ce18",
    "logs": [],
    "blockNumber": 44403010,
    "cumulativeGasUsed": "2972536",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 4,
  "solcInputHash": "d898feb8f7243bc577be94f833c69634",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"extractArray\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"extractDynamicArray\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"extractDynamicElement\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"extractElement\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool[]\",\"name\":\"isDynamicTypeFormat\",\"type\":\"bool[]\"}],\"name\":\"extractTuple\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool[]\",\"name\":\"isDynamicTypeFormat\",\"type\":\"bool[]\"}],\"name\":\"extractTupleArray\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"extractArray(bytes,uint256)\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the array to be extracted\",\"tuple\":\"The bytes encoded array\"}},\"extractDynamicArray(bytes,uint256)\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the dynamic array to be extracted\",\"tuple\":\"The bytes encoded tuple\"}},\"extractDynamicElement(bytes,uint256)\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the string or bytes to be extracted\",\"tuple\":\"The bytes encoded tuple\"}},\"extractElement(bytes,uint256)\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the value to be extracted\",\"tuple\":\"The bytes encoded tuple\"}},\"extractTuple(bytes,uint256,bool[])\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the tuple to be extracted\",\"isDynamicTypeFormat\":\"Boolean to define whether the child tuple is dynamically sized. If the child tuple contains bytes or string variables, set to \\\"true\\\"\",\"tuple\":\"The bytes encoded parent tuple\"}},\"extractTupleArray(bytes,uint256,bool[])\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the tuple array to be extracted\",\"isDynamicTypeFormat\":\"Boolean to define whether the tuples in the array are dynamically sized. If the array tuple contains bytes or string variables, set to \\\"true\\\"\",\"tuple\":\"The bytes encoded tuple\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"extractArray(bytes,uint256)\":{\"notice\":\"Extract a bytes encoded static array from a tuple\"},\"extractDynamicArray(bytes,uint256)\":{\"notice\":\"Extract a bytes encoded dynamic array from a tuple\"},\"extractDynamicElement(bytes,uint256)\":{\"notice\":\"Extract a bytes encoded dynamic type from a tuple\"},\"extractElement(bytes,uint256)\":{\"notice\":\"Extract a bytes32 encoded static type from a tuple\"},\"extractTuple(bytes,uint256,bool[])\":{\"notice\":\"Extract a bytes encoded tuple from another tuple\"},\"extractTupleArray(bytes,uint256,bool[])\":{\"notice\":\"Extract a bytes encoded array of tuples from a tuple\"}},\"notice\":\"Helper contract to extract a variety of types from a tuple within the context of a weiroll script\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/helpers/TupleHelpers.sol\":\"TupleHelpers\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/helpers/TupleHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @notice Helper contract to extract a variety of types from a tuple within the context of a weiroll script\\n */\\ncontract TupleHelpers {\\n    /**\\n     * @notice Extract a bytes32 encoded static type from a tuple\\n     * @dev Use with .rawValue() in the weiroll planner\\n     * @param tuple The bytes encoded tuple\\n     * @param index The index of the value to be extracted\\n     */\\n    function extractElement(bytes memory tuple, uint256 index) public pure returns (bytes32) {\\n        assembly {\\n            // let offset := mul(add(index, 1), 32)\\n            // return(add(tuple, offset), 32)\\n            return(add(tuple, mul(add(index, 1), 32)), 32)\\n        }\\n    }\\n\\n    /**\\n     * @notice Extract a bytes encoded dynamic type from a tuple\\n     * @dev Use with .rawValue() in the weiroll planner\\n     * @param tuple The bytes encoded tuple\\n     * @param index The index of the string or bytes to be extracted\\n     */\\n    function extractDynamicElement(bytes memory tuple, uint256 index) public pure returns (bytes32) {\\n        assembly {\\n            let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\\n            let length := mload(add(tuple, offset))\\n            if gt(mod(length, 32), 0) {\\n                length := mul(add(div(length, 32), 1), 32)\\n            }\\n            return(add(tuple, add(offset, 32)), length)\\n        }\\n    }\\n\\n    /**\\n     * @notice Extract a bytes encoded tuple from another tuple\\n     * @dev Use with .rawValue() in the weiroll planner\\n     * @param tuple The bytes encoded parent tuple\\n     * @param index The index of the tuple to be extracted\\n     * @param isDynamicTypeFormat Boolean to define whether the child tuple is dynamically sized. If the child tuple contains bytes or string variables, set to \\\"true\\\"\\n     */\\n    function extractTuple(\\n        bytes memory tuple,\\n        uint256 index,\\n        bool[] memory isDynamicTypeFormat\\n    ) public pure returns (bytes32) {\\n        uint256 offset;\\n        uint256 length;\\n        assembly {\\n            offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\\n        }\\n        for (uint256 i = 0; i < isDynamicTypeFormat.length; i++) {\\n            length += 32;\\n            if (isDynamicTypeFormat[i]) {\\n                assembly {\\n                    let paramOffset := add(offset, mload(add(tuple, add(offset, mul(i, 32)))))\\n                    let paramLength := add(mload(add(tuple, paramOffset)), 32)\\n                    if gt(mod(paramLength, 32), 0) {\\n                        paramLength := mul(add(div(paramLength, 32), 1), 32)\\n                    }\\n                    length := add(length, paramLength)\\n                }\\n            }\\n        }\\n        assembly {\\n            return(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)), length)\\n        }\\n    }\\n\\n    /**\\n     * @notice Extract a bytes encoded static array from a tuple\\n     * @dev Use with .rawValue() in the weiroll planner\\n     * @param tuple The bytes encoded array\\n     * @param index The index of the array to be extracted\\n     */\\n    function extractArray(bytes memory tuple, uint256 index) public pure returns (bytes32) {\\n        assembly {\\n            // let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\\n            // let numberOfElements := mload(add(tuple, offset))\\n            // return(add(tuple, add(offset, 32)), mul(numberOfElements, 32))\\n            return(\\n                add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)),\\n                mul(mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32))), 32)\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice Extract a bytes encoded dynamic array from a tuple\\n     * @dev Use with .rawValue() in the weiroll planner\\n     * @param tuple The bytes encoded tuple\\n     * @param index The index of the dynamic array to be extracted\\n     */\\n    function extractDynamicArray(bytes memory tuple, uint256 index) public pure returns (bytes32) {\\n        uint256 numberOfElements;\\n        uint256 offset;\\n        assembly {\\n            offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\\n            numberOfElements := mload(add(tuple, offset))\\n            //numberOfElements := mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)))\\n        }\\n\\n        uint256 length;\\n        for (uint256 i = 1; i <= numberOfElements; i++) {\\n            assembly {\\n                let paramOffset := add(offset, mul(add(i, 1), 32))\\n                let paramLength := mload(add(tuple, paramOffset))\\n                if gt(mod(paramLength, 32), 0) {\\n                    paramLength := mul(add(div(paramLength, 32), 1), 32)\\n                }\\n                length := add(length, paramLength)\\n                //length := add(length, mload(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), mul(add(i, 1), 32)))))\\n            }\\n        }\\n        assembly {\\n            // return(add(tuple, add(offset, 32)), add(length, 32))\\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)), add(length, 32))\\n        }\\n    }\\n\\n    /**\\n     * @notice Extract a bytes encoded array of tuples from a tuple\\n     * @dev Use with .rawValue() in the weiroll planner\\n     * @param tuple The bytes encoded tuple\\n     * @param index The index of the tuple array to be extracted\\n     * @param isDynamicTypeFormat Boolean to define whether the tuples in the array are dynamically sized. If the array tuple contains bytes or string variables, set to \\\"true\\\"\\n     */\\n    function extractTupleArray(\\n        bytes memory tuple,\\n        uint256 index,\\n        bool[] memory isDynamicTypeFormat\\n    ) public pure returns (bytes32) {\\n        uint256 numberOfElements;\\n        assembly {\\n            // let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\\n            // numberOfElements := mload(add(tuple, offset))\\n            numberOfElements := mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)))\\n        }\\n        uint256 length = numberOfElements * 32;\\n        for (uint256 i = 1; i <= numberOfElements; i++) {\\n            for (uint256 j = 0; j < isDynamicTypeFormat.length; j++) {\\n                length += 32;\\n                if (isDynamicTypeFormat[j]) {\\n                    assembly {\\n                        // let tupleOffset := add(offset,mload(add(tuple, add(offset, mul(i, 32)))))\\n                        // let paramOffset := add(tupleOffset, mload(add(tuple, add(tupleOffset, mul(add(j,1), 32)))))\\n                        // let paramLength := add(mload(add(tuple, paramOffset)),32)\\n                        // length := add(length, paramLength)\\n                        length := add(\\n                            length,\\n                            add(\\n                                mload(\\n                                    add(\\n                                        tuple,\\n                                        add(\\n                                            add(\\n                                                add(mload(add(tuple, mul(add(index, 1), 32))), 32),\\n                                                mload(\\n                                                    add(\\n                                                        tuple,\\n                                                        add(\\n                                                            add(mload(add(tuple, mul(add(index, 1), 32))), 32),\\n                                                            mul(i, 32)\\n                                                        )\\n                                                    )\\n                                                )\\n                                            ),\\n                                            mload(\\n                                                add(\\n                                                    tuple,\\n                                                    add(\\n                                                        add(\\n                                                            add(mload(add(tuple, mul(add(index, 1), 32))), 32),\\n                                                            mload(\\n                                                                add(\\n                                                                    tuple,\\n                                                                    add(\\n                                                                        add(\\n                                                                            mload(add(tuple, mul(add(index, 1), 32))),\\n                                                                            32\\n                                                                        ),\\n                                                                        mul(i, 32)\\n                                                                    )\\n                                                                )\\n                                                            )\\n                                                        ),\\n                                                        mul(add(j, 1), 32)\\n                                                    )\\n                                                )\\n                                            )\\n                                        )\\n                                    )\\n                                ),\\n                                32\\n                            )\\n                        )\\n                    }\\n                }\\n            }\\n        }\\n        assembly {\\n            // return(add(tuple, add(offset,32)), length)\\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)), length)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x32ba4699f9ee114e034d6e503c0db0016a68474d4387f849d072e43ba77c63c3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001657610676908161001c8239f35b600080fdfe60806040526004361015610013575b600080fd5b60003560e01c80632fb402541461008b57806348f26302146100825780635305afc0146100795780639bd3b22714610070578063a208b031146100675763df6d76b51461005f57600080fd5b61000e61050f565b5061000e61044b565b5061000e61042e565b5061000e6103ae565b5061000e61036e565b3461000e576100993661024e565b91600091600180948160059301831b840192835186975b6100bf575b8660208787510101f35b909192958351881015610148576100d5906105a3565b96876100ea6100e483876105bb565b51151590565b610105575b50906100fb8792610569565b97969392916100b0565b87929198506100fb906020908482808d891b87018c01015186018b0101519280808501940861013a575b5001989192506100ef565b9091861c01851b908461012f565b956100b5565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f604051930116820182811067ffffffffffffffff8211176101c257604052565b6101ca61014e565b604052565b81601f8201121561000e5780359067ffffffffffffffff8211610241575b61021e60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8501160161017e565b928284526020838301011161000e57816000926020809301838601378301015290565b61024961014e565b6101ed565b60607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82011261000e5767ffffffffffffffff9160043583811161000e5782610299916004016101cf565b92602435926044359082821161000e578060238301121561000e578160040135928311610311575b8260051b6020926024846102d681850161017e565b80978152019282010192831161000e57602401905b8282106102f9575050505090565b8135801515810361000e5781529083019083016102eb565b61031961014e565b6102c1565b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82011261000e576004359067ffffffffffffffff821161000e57610367916004016101cf565b9060243590565b503461000e57600161037f3661031e565b9190910160051b81015101602081015190601f821661039d57604001f35b600591821c60010190911b90604001f35b503461000e576103bd3661031e565b6001918260059201821b81019182519360209182868501015160009280925b828411156103f1578760408888880192510101f35b909192936104189086848701841b8b01890101519084601f8316610420575b500194610569565b9291906103dc565b9091841c01831b9084610410565b503461000e57602060016104413661031e565b9190910160051b01f35b503461000e5761045a3661024e565b909160018060059401841b8201906020808351850101519461047b866105fe565b96835b87811115610490578860408888510101f35b6000855b6104a8575b506104a390610569565b61047e565b9883518a1015610509576104bb906105a3565b986104c96100e482866105bb565b6104de575b6104d88691610569565b90610494565b865182841b8101890186015101818701841b81018901860151018801850151999099018401986104ce565b98610499565b503461000e5760016105203661031e565b9190910160051b810151016040602082015160051b9101f35b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6001907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610597570190565b61059f610539565b0190565b90602082018092116105b157565b6105b9610539565b565b80518210156105cf5760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0460201181151516610633575b60051b90565b61063b610539565b61062d56fea2646970667358221220ce03d64a768054f2ec48b6f7e7d78846c37103e74da7a47a8751004af8aadc6664736f6c63430008100033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b60003560e01c80632fb402541461008b57806348f26302146100825780635305afc0146100795780639bd3b22714610070578063a208b031146100675763df6d76b51461005f57600080fd5b61000e61050f565b5061000e61044b565b5061000e61042e565b5061000e6103ae565b5061000e61036e565b3461000e576100993661024e565b91600091600180948160059301831b840192835186975b6100bf575b8660208787510101f35b909192958351881015610148576100d5906105a3565b96876100ea6100e483876105bb565b51151590565b610105575b50906100fb8792610569565b97969392916100b0565b87929198506100fb906020908482808d891b87018c01015186018b0101519280808501940861013a575b5001989192506100ef565b9091861c01851b908461012f565b956100b5565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f604051930116820182811067ffffffffffffffff8211176101c257604052565b6101ca61014e565b604052565b81601f8201121561000e5780359067ffffffffffffffff8211610241575b61021e60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8501160161017e565b928284526020838301011161000e57816000926020809301838601378301015290565b61024961014e565b6101ed565b60607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82011261000e5767ffffffffffffffff9160043583811161000e5782610299916004016101cf565b92602435926044359082821161000e578060238301121561000e578160040135928311610311575b8260051b6020926024846102d681850161017e565b80978152019282010192831161000e57602401905b8282106102f9575050505090565b8135801515810361000e5781529083019083016102eb565b61031961014e565b6102c1565b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82011261000e576004359067ffffffffffffffff821161000e57610367916004016101cf565b9060243590565b503461000e57600161037f3661031e565b9190910160051b81015101602081015190601f821661039d57604001f35b600591821c60010190911b90604001f35b503461000e576103bd3661031e565b6001918260059201821b81019182519360209182868501015160009280925b828411156103f1578760408888880192510101f35b909192936104189086848701841b8b01890101519084601f8316610420575b500194610569565b9291906103dc565b9091841c01831b9084610410565b503461000e57602060016104413661031e565b9190910160051b01f35b503461000e5761045a3661024e565b909160018060059401841b8201906020808351850101519461047b866105fe565b96835b87811115610490578860408888510101f35b6000855b6104a8575b506104a390610569565b61047e565b9883518a1015610509576104bb906105a3565b986104c96100e482866105bb565b6104de575b6104d88691610569565b90610494565b865182841b8101890186015101818701841b81018901860151018801850151999099018401986104ce565b98610499565b503461000e5760016105203661031e565b9190910160051b810151016040602082015160051b9101f35b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6001907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610597570190565b61059f610539565b0190565b90602082018092116105b157565b6105b9610539565b565b80518210156105cf5760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0460201181151516610633575b60051b90565b61063b610539565b61062d56fea2646970667358221220ce03d64a768054f2ec48b6f7e7d78846c37103e74da7a47a8751004af8aadc6664736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "extractArray(bytes,uint256)": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the array to be extracted",
          "tuple": "The bytes encoded array"
        }
      },
      "extractDynamicArray(bytes,uint256)": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the dynamic array to be extracted",
          "tuple": "The bytes encoded tuple"
        }
      },
      "extractDynamicElement(bytes,uint256)": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the string or bytes to be extracted",
          "tuple": "The bytes encoded tuple"
        }
      },
      "extractElement(bytes,uint256)": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the value to be extracted",
          "tuple": "The bytes encoded tuple"
        }
      },
      "extractTuple(bytes,uint256,bool[])": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the tuple to be extracted",
          "isDynamicTypeFormat": "Boolean to define whether the child tuple is dynamically sized. If the child tuple contains bytes or string variables, set to \"true\"",
          "tuple": "The bytes encoded parent tuple"
        }
      },
      "extractTupleArray(bytes,uint256,bool[])": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the tuple array to be extracted",
          "isDynamicTypeFormat": "Boolean to define whether the tuples in the array are dynamically sized. If the array tuple contains bytes or string variables, set to \"true\"",
          "tuple": "The bytes encoded tuple"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "extractArray(bytes,uint256)": {
        "notice": "Extract a bytes encoded static array from a tuple"
      },
      "extractDynamicArray(bytes,uint256)": {
        "notice": "Extract a bytes encoded dynamic array from a tuple"
      },
      "extractDynamicElement(bytes,uint256)": {
        "notice": "Extract a bytes encoded dynamic type from a tuple"
      },
      "extractElement(bytes,uint256)": {
        "notice": "Extract a bytes32 encoded static type from a tuple"
      },
      "extractTuple(bytes,uint256,bool[])": {
        "notice": "Extract a bytes encoded tuple from another tuple"
      },
      "extractTupleArray(bytes,uint256,bool[])": {
        "notice": "Extract a bytes encoded array of tuples from a tuple"
      }
    },
    "notice": "Helper contract to extract a variety of types from a tuple within the context of a weiroll script",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}