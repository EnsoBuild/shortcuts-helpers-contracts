{
  "language": "Solidity",
  "sources": {
    "contracts/TupleHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @notice Helper contract to extract a variety of types from a tuple within the context of a weiroll script\n */\ncontract TupleHelpers {\n    /**\n     * @notice Extract a bytes32 encoded static type from a tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded tuple\n     * @param index The index of the value to be extracted\n     */\n    function extractElement(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        assembly {\n            // let offset := mul(add(index, 1), 32)\n            // return(add(tuple, offset), 32)\n            return(add(tuple, mul(add(index, 1), 32)), 32)\n        }\n    }\n\n    /**\n     * @notice Extract a bytes encoded dynamic type from a tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded tuple\n     * @param index The index of the string or bytes to be extracted\n     */\n    function extractDynamicElement(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        assembly {\n            let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            let length := mload(add(tuple, offset))\n            if gt(mod(length, 32), 0) {\n                length := mul(add(div(length, 32), 1), 32)\n            }\n            return(add(tuple, add(offset, 32)), length)\n        }\n    }\n\n    /**\n     * @notice Extract a bytes encoded tuple from another tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded parent tuple\n     * @param index The index of the tuple to be extracted\n     * @param isDynamicTypeFormat Boolean to define whether the child tuple is dynamically sized. If the child tuple contains bytes or string variables, set to \"true\"\n     */\n    function extractTuple(\n        bytes memory tuple,\n        uint256 index,\n        bool[] memory isDynamicTypeFormat\n    ) public pure returns (bytes32) {\n        uint256 offset;\n        uint256 length;\n        assembly {\n            offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n        }\n        for (uint256 i = 0; i < isDynamicTypeFormat.length; i++) {\n            length += 32;\n            if (isDynamicTypeFormat[i]) {\n                assembly {\n                    let paramOffset := add(offset, mload(add(tuple, add(offset, mul(i, 32)))))\n                    let paramLength := add(mload(add(tuple, paramOffset)), 32)\n                    if gt(mod(paramLength, 32), 0) {\n                        paramLength := mul(add(div(paramLength, 32), 1), 32)\n                    }\n                    length := add(length, paramLength)\n                }\n            }\n        }\n        assembly {\n            return(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)), length)\n        }\n    }\n\n    /**\n     * @notice Extract a bytes encoded static array from a tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded array\n     * @param index The index of the array to be extracted\n     */\n    function extractArray(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        assembly {\n            // let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            // let numberOfElements := mload(add(tuple, offset))\n            // return(add(tuple, add(offset, 32)), mul(numberOfElements, 32))\n            return(\n                add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)),\n                mul(mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32))), 32)\n            )\n        }\n    }\n\n    /**\n     * @notice Extract a bytes encoded dynamic array from a tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded tuple\n     * @param index The index of the dynamic array to be extracted\n     */\n    function extractDynamicArray(bytes memory tuple, uint256 index) public pure returns (bytes32) {\n        uint256 numberOfElements;\n        uint256 offset;\n        assembly {\n            offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            numberOfElements := mload(add(tuple, offset))\n            //numberOfElements := mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)))\n        }\n\n        uint256 length;\n        for (uint256 i = 1; i <= numberOfElements; i++) {\n            assembly {\n                let paramOffset := add(offset, mul(add(i, 1), 32))\n                let paramLength := mload(add(tuple, paramOffset))\n                if gt(mod(paramLength, 32), 0) {\n                    paramLength := mul(add(div(paramLength, 32), 1), 32)\n                }\n                length := add(length, paramLength)\n                //length := add(length, mload(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), mul(add(i, 1), 32)))))\n            }\n        }\n        assembly {\n            // return(add(tuple, add(offset, 32)), add(length, 32))\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)), add(length, 32))\n        }\n    }\n\n    /**\n     * @notice Extract a bytes encoded array of tuples from a tuple\n     * @dev Use with .rawValue() in the weiroll planner\n     * @param tuple The bytes encoded tuple\n     * @param index The index of the tuple array to be extracted\n     * @param isDynamicTypeFormat Boolean to define whether the tuples in the array are dynamically sized. If the array tuple contains bytes or string variables, set to \"true\"\n     */\n    function extractTupleArray(\n        bytes memory tuple,\n        uint256 index,\n        bool[] memory isDynamicTypeFormat\n    ) public pure returns (bytes32) {\n        uint256 numberOfElements;\n        assembly {\n            // let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\n            // numberOfElements := mload(add(tuple, offset))\n            numberOfElements := mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)))\n        }\n        uint256 length = numberOfElements * 32;\n        for (uint256 i = 1; i <= numberOfElements; i++) {\n            for (uint256 j = 0; j < isDynamicTypeFormat.length; j++) {\n                length += 32;\n                if (isDynamicTypeFormat[j]) {\n                    assembly {\n                        // let tupleOffset := add(offset,mload(add(tuple, add(offset, mul(i, 32)))))\n                        // let paramOffset := add(tupleOffset, mload(add(tuple, add(tupleOffset, mul(add(j,1), 32)))))\n                        // let paramLength := add(mload(add(tuple, paramOffset)),32)\n                        // length := add(length, paramLength)\n                        length := add(\n                            length,\n                            add(\n                                mload(\n                                    add(\n                                        tuple,\n                                        add(\n                                            add(\n                                                add(mload(add(tuple, mul(add(index, 1), 32))), 32),\n                                                mload(\n                                                    add(\n                                                        tuple,\n                                                        add(\n                                                            add(mload(add(tuple, mul(add(index, 1), 32))), 32),\n                                                            mul(i, 32)\n                                                        )\n                                                    )\n                                                )\n                                            ),\n                                            mload(\n                                                add(\n                                                    tuple,\n                                                    add(\n                                                        add(\n                                                            add(mload(add(tuple, mul(add(index, 1), 32))), 32),\n                                                            mload(\n                                                                add(\n                                                                    tuple,\n                                                                    add(\n                                                                        add(\n                                                                            mload(add(tuple, mul(add(index, 1), 32))),\n                                                                            32\n                                                                        ),\n                                                                        mul(i, 32)\n                                                                    )\n                                                                )\n                                                            )\n                                                        ),\n                                                        mul(add(j, 1), 32)\n                                                    )\n                                                )\n                                            )\n                                        )\n                                    )\n                                ),\n                                32\n                            )\n                        )\n                    }\n                }\n            }\n        }\n        assembly {\n            // return(add(tuple, add(offset,32)), length)\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)), length)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}