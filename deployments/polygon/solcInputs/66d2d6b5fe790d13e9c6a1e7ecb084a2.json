{
  "language": "Solidity",
  "sources": {
    "@ensofinance/weiroll/contracts/CommandBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nlibrary CommandBuilder {\n    uint256 constant IDX_VARIABLE_LENGTH = 0x80;\n    uint256 constant IDX_VALUE_MASK = 0x7f;\n    uint256 constant IDX_END_OF_ARGS = 0xff;\n    uint256 constant IDX_USE_STATE = 0xfe;\n    uint256 constant IDX_ARRAY_START = 0xfd;\n    uint256 constant IDX_TUPLE_START = 0xfc;\n    uint256 constant IDX_DYNAMIC_END = 0xfb;\n\n    function buildInputs(\n        bytes[] memory state,\n        bytes4 selector,\n        bytes32 indices\n    ) internal view returns (bytes memory ret) {\n        uint256 idx; // The current command index\n        uint256 offsetIdx; // The index of the current free offset\n\n        uint256 count; // Number of bytes in whole ABI encoded message\n        uint256 free; // Pointer to first free byte in tail part of message\n        uint256[] memory offsets = new uint256[](10); // Optionally store the length of all dynamic types (a command cannot fit more than 10 dynamic types)\n\n        bytes memory stateData; // Optionally encode the current state if the call requires it\n\n        uint256 indicesLength; // Number of indices\n\n        // Determine the length of the encoded data\n        for (uint256 i; i < 32; ) {\n            idx = uint8(indices[i]);\n            if (idx == IDX_END_OF_ARGS) {\n                indicesLength = i;\n                break;\n            }\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\n                if (idx == IDX_USE_STATE) {\n                    if (stateData.length == 0) {\n                        stateData = abi.encode(state);\n                    }\n                    unchecked {\n                        count += stateData.length;\n                    }\n                } else if (idx == IDX_ARRAY_START) {\n                    (offsets, offsetIdx, count, i) = setupDynamicArray(state, indices, offsets, offsetIdx, count, i);\n                } else if (idx == IDX_TUPLE_START) {\n                    (offsets, offsetIdx, count, i) = setupDynamicTuple(state, indices, offsets, offsetIdx, count, i);\n                } else {\n                    count = setupDynamicVariable(state, count, idx);\n                }\n            } else {\n                count = setupStaticVariable(state, count, idx);\n            }\n            unchecked {\n                free += 32;\n                ++i;\n            }\n        }\n\n        // Encode it\n        ret = new bytes(count + 4);\n        assembly {\n            mstore(add(ret, 32), selector)\n        }\n        count = 0;\n        offsetIdx = 0;\n        for (uint256 i; i < indicesLength; ) {\n            idx = uint8(indices[i]);\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\n                if (idx == IDX_USE_STATE) {\n                    assembly {\n                        mstore(add(add(ret, 36), count), free)\n                    }\n                    memcpy(stateData, 32, ret, free + 4, stateData.length - 32);\n                    unchecked {\n                        free += stateData.length - 32;\n                        count += 32;\n                    }\n                } else if (idx == IDX_ARRAY_START) {\n                    // Start of dynamic type, put pointer in current slot\n                    assembly {\n                        mstore(add(add(ret, 36), count), free)\n                    }\n                    (offsetIdx, free, , i) = encodeDynamicArray(ret, state, indices, offsets, offsetIdx, free, i);\n                    unchecked {\n                        count += 32;\n                    }\n                } else if (idx == IDX_TUPLE_START) {\n                    // Start of dynamic type, put pointer in current slot\n                    assembly {\n                        mstore(add(add(ret, 36), count), free)\n                    }\n                    (offsetIdx, free, , i) = encodeDynamicTuple(ret, state, indices, offsets, offsetIdx, free, i);\n                    unchecked {\n                        count += 32;\n                    }\n                } else {\n                    // Variable length data\n                    uint256 argLen = state[idx & IDX_VALUE_MASK].length;\n                    // Put a pointer in the current slot and write the data to first free slot\n                    assembly {\n                        mstore(add(add(ret, 36), count), free)\n                    }\n                    memcpy(\n                        state[idx & IDX_VALUE_MASK],\n                        0,\n                        ret,\n                        free + 4,\n                        argLen\n                    );\n                    unchecked {\n                        free += argLen;\n                        count += 32;\n                    }\n                }\n            } else {\n                // Fixed length data\n                bytes memory stateVar = state[idx & IDX_VALUE_MASK];\n                // Write the data to current slot\n                assembly {\n                    mstore(add(add(ret, 36), count), mload(add(stateVar, 32)))\n                }\n                unchecked {\n                    count += 32;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function setupStaticVariable(\n        bytes[] memory state,\n        uint256 count,\n        uint256 idx\n    ) internal pure returns (uint256) {\n        require(\n            state[idx & IDX_VALUE_MASK].length == 32,\n            \"Static state variables must be 32 bytes\"\n        );\n        unchecked {\n            count += 32;\n        }\n        return count;\n    }\n\n    function setupDynamicVariable(\n        bytes[] memory state,\n        uint256 count,\n        uint256 idx\n    ) internal pure returns (uint256) {\n        // Add the length of the value, rounded up to the next word boundary, plus space for pointer and length\n        uint256 argLen = state[idx & IDX_VALUE_MASK].length;\n        require(\n            argLen % 32 == 0,\n            \"Dynamic state variables must be a multiple of 32 bytes\"\n        );\n        unchecked {\n            count += argLen + 32;\n        }\n        return count;\n    }\n\n    function setupDynamicArray(\n        bytes[] memory state,\n        bytes32 indices,\n        uint256[] memory offsets,\n        uint256 offsetIdx,\n        uint256 count,\n        uint256 i\n    ) internal view returns (uint256[] memory, uint256, uint256, uint256) {\n        // Current idx is IDX_ARRAY_START, next idx will contain the array length\n        unchecked {\n            ++i;\n            count += 32;\n        }\n        uint256 idx = uint8(indices[i]);\n        require(\n            state[idx & IDX_VALUE_MASK].length == 32,\n            \"Array length must be 32 bytes\"\n        );\n        return setupDynamicTuple(state, indices, offsets, offsetIdx, count, i);\n    }\n\n    function setupDynamicTuple(\n        bytes[] memory state,\n        bytes32 indices,\n        uint256[] memory offsets,\n        uint256 offsetIdx,\n        uint256 count,\n        uint256 i\n    ) internal view returns (uint256[] memory, uint256, uint256, uint256) {\n        uint256 idx;\n        uint256 offset;\n        uint256 nextOffsetIdx;\n        // Progress to first index of the data and progress the next offset idx\n        unchecked {\n            ++i;\n            nextOffsetIdx = offsetIdx + 1;\n            count += 32;\n        }\n        while (i < 32) {\n            idx = uint8(indices[i]);\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\n                if (idx == IDX_DYNAMIC_END) {\n                    offsets[offsetIdx] = offset;\n                    // Return\n                    return (offsets, nextOffsetIdx, count, i);\n                } else if (idx == IDX_ARRAY_START) {\n                    (offsets, nextOffsetIdx, count, i) = setupDynamicArray(state, indices, offsets, nextOffsetIdx, count, i);\n                } else if (idx == IDX_TUPLE_START) {\n                    (offsets, nextOffsetIdx, count, i) = setupDynamicTuple(state, indices, offsets, nextOffsetIdx, count, i);\n                } else {\n                    count = setupDynamicVariable(state, count, idx);\n                }\n            } else {\n                count = setupStaticVariable(state, count, idx);\n            }\n            unchecked {\n                offset += 32;\n                ++i;\n            }\n        }\n        return (offsets, nextOffsetIdx, count, i);\n    }\n\n    function encodeDynamicArray(\n        bytes memory ret,\n        bytes[] memory state,\n        bytes32 indices,\n        uint256[] memory offsets,\n        uint256 offsetIdx,\n        uint256 free,\n        uint256 i\n    ) internal view returns (uint256, uint256, uint256, uint256) {\n        // Progress to array length metadata\n        unchecked {\n            ++i;\n        }\n        // Encode array length\n        uint256 idx = uint8(indices[i]);\n        bytes memory stateVar = state[idx & IDX_VALUE_MASK];\n        assembly {\n            mstore(add(add(ret, 36), free), mload(add(stateVar, 32)))\n        }\n        unchecked {\n            free += 32;\n        }\n        uint256 length;\n        (offsetIdx, free, length, i) = encodeDynamicTuple(ret, state, indices, offsets, offsetIdx, free, i);\n        unchecked {\n            length += 32; // Increase length to account for array length metadata\n        }\n        return (offsetIdx, free, length, i);\n    }\n\n    function encodeDynamicTuple(\n        bytes memory ret,\n        bytes[] memory state,\n        bytes32 indices,\n        uint256[] memory offsets,\n        uint256 offsetIdx,\n        uint256 free,\n        uint256 i\n    ) internal view returns (uint256, uint256, uint256, uint256) {\n        uint256 idx;\n        uint256 length; // The number of bytes in this tuple\n        uint256 offset = offsets[offsetIdx]; // The current offset location\n        uint256 pointer = offset; // The current pointer for dynamic types\n        unchecked {\n            offset += free; // Update the offset location\n            ++offsetIdx; // Progress to next offsetIdx\n            ++i; // Progress to first index of the data\n        }\n        while (i < 32) {\n            idx = uint8(indices[i]);\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\n                if (idx == IDX_DYNAMIC_END) {\n                    return (offsetIdx, offset, length, i);\n                } else if (idx == IDX_ARRAY_START) {\n                    // Start of dynamic type, put pointer in current slot\n                    assembly {\n                        mstore(add(add(ret, 36), free), pointer)\n                    }\n                    uint256 argLen;\n                    (offsetIdx, offset, argLen, i) = encodeDynamicArray(ret, state, indices, offsets, offsetIdx, offset, i);\n                    unchecked {\n                        pointer += argLen;\n                        length += (argLen + 32); // data + pointer\n                        free += 32;\n                    }\n                } else if (idx == IDX_TUPLE_START) {\n                    // Start of dynamic type, put pointer in current slot\n                    assembly {\n                        mstore(add(add(ret, 36), free), pointer)\n                    }\n                    uint256 argLen;\n                    (offsetIdx, offset, argLen, i) = encodeDynamicTuple(ret, state, indices, offsets, offsetIdx, offset, i);\n                    unchecked {\n                        pointer += argLen;\n                        length += (argLen + 32); // data + pointer\n                        free += 32;\n                    }\n                } else  {\n                    // Variable length data\n                    uint256 argLen = state[idx & IDX_VALUE_MASK].length;\n                    // Put a pointer in the first free slot and write the data to the offset free slot\n                    assembly {\n                        mstore(add(add(ret, 36), free), pointer)\n                    }\n                    memcpy(\n                        state[idx & IDX_VALUE_MASK],\n                        0,\n                        ret,\n                        offset + 4,\n                        argLen\n                    );\n                    unchecked {\n                        offset += argLen;\n                        pointer += argLen;\n                        length += (argLen + 32); // data + pointer\n                        free += 32;\n                    }\n                }\n            } else {\n                // Fixed length data\n                bytes memory stateVar = state[idx & IDX_VALUE_MASK];\n                // Write to first free slot\n                assembly {\n                    mstore(add(add(ret, 36), free), mload(add(stateVar, 32)))\n                }\n                unchecked {\n                    length += 32;\n                    free += 32;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return (offsetIdx, offset, length, i);\n    }\n\n    function writeOutputs(\n        bytes[] memory state,\n        bytes1 index,\n        bytes memory output\n    ) internal pure returns (bytes[] memory) {\n        uint256 idx = uint8(index);\n        if (idx == IDX_END_OF_ARGS) return state;\n\n        if (idx & IDX_VARIABLE_LENGTH != 0) {\n            if (idx == IDX_USE_STATE) {\n                state = abi.decode(output, (bytes[]));\n            } else {\n                // Check the first field is 0x20 (because we have only a single return value)\n                uint256 argPtr;\n                assembly {\n                    argPtr := mload(add(output, 32))\n                }\n                require(\n                    argPtr == 32,\n                    \"Only one return value permitted (variable)\"\n                );\n\n                assembly {\n                    // Overwrite the first word of the return data with the length - 32\n                    mstore(add(output, 32), sub(mload(output), 32))\n                    // Insert a pointer to the return data, starting at the second word, into state\n                    mstore(\n                        add(add(state, 32), mul(and(idx, IDX_VALUE_MASK), 32)),\n                        add(output, 32)\n                    )\n                }\n            }\n        } else {\n            // Single word\n            require(\n                output.length == 32,\n                \"Only one return value permitted (static)\"\n            );\n\n            state[idx & IDX_VALUE_MASK] = output;\n        }\n\n        return state;\n    }\n\n    function writeTuple(\n        bytes[] memory state,\n        bytes1 index,\n        bytes memory output\n    ) internal view {\n        uint256 idx = uint8(index);\n        if (idx == IDX_END_OF_ARGS) return;\n\n        bytes memory entry = state[idx] = new bytes(output.length + 32);\n        memcpy(output, 0, entry, 32, output.length);\n        assembly {\n            let l := mload(output)\n            mstore(add(entry, 32), l)\n        }\n    }\n\n    function memcpy(\n        bytes memory src,\n        uint256 srcIdx,\n        bytes memory dest,\n        uint256 destIdx,\n        uint256 len\n    ) internal view {\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    4,\n                    add(add(src, 32), srcIdx),\n                    len,\n                    add(add(dest, 32), destIdx),\n                    len\n                )\n            )\n        }\n    }\n}\n"
    },
    "@ensofinance/weiroll/contracts/VM.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"./CommandBuilder.sol\";\n\nabstract contract VM {\n    using CommandBuilder for bytes[];\n\n    uint256 constant FLAG_CT_DELEGATECALL = 0x00;\n    uint256 constant FLAG_CT_CALL = 0x01;\n    uint256 constant FLAG_CT_STATICCALL = 0x02;\n    uint256 constant FLAG_CT_VALUECALL = 0x03;\n    uint256 constant FLAG_CT_MASK = 0x03;\n    uint256 constant FLAG_DATA = 0x20;\n    uint256 constant FLAG_EXTENDED_COMMAND = 0x40;\n    uint256 constant FLAG_TUPLE_RETURN = 0x80;\n\n    uint256 constant SHORT_COMMAND_FILL =\n        0x000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    error ExecutionFailed(\n        uint256 command_index,\n        address target,\n        string message\n    );\n\n    function _execute(bytes32[] calldata commands, bytes[] memory state)\n        internal\n        returns (bytes[] memory)\n    {\n        bytes32 command;\n        uint256 flags;\n        bytes32 indices;\n\n        bool success;\n        bytes memory outData;\n\n        uint256 commandsLength = commands.length;\n        for (uint256 i; i < commandsLength; i = _uncheckedIncrement(i)) {\n            command = commands[i];\n            flags = uint256(uint8(bytes1(command << 32)));\n\n            if (flags & FLAG_EXTENDED_COMMAND != 0) {\n                i = _uncheckedIncrement(i);\n                indices = commands[i];\n            } else {\n                indices = bytes32(uint256(command << 40) | SHORT_COMMAND_FILL);\n            }\n\n            if (flags & FLAG_CT_MASK == FLAG_CT_DELEGATECALL) {\n                (success, outData) = address(uint160(uint256(command))) // target\n                    .delegatecall(\n                        // inputs\n                        flags & FLAG_DATA == 0\n                            ? state.buildInputs(\n                                bytes4(command), // selector\n                                indices\n                            )\n                            : state[\n                                uint8(bytes1(indices)) &\n                                CommandBuilder.IDX_VALUE_MASK\n                            ]\n                    );\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_CALL) {\n                (success, outData) = address(uint160(uint256(command))).call( // target\n                    // inputs\n                    flags & FLAG_DATA == 0\n                        ? state.buildInputs(\n                            bytes4(command), // selector\n                            indices\n                        )\n                        : state[\n                            uint8(bytes1(indices)) &\n                            CommandBuilder.IDX_VALUE_MASK\n                        ]\n                );\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_STATICCALL) {\n                (success, outData) = address(uint160(uint256(command))) // target\n                    .staticcall(\n                        // inputs\n                        flags & FLAG_DATA == 0\n                            ? state.buildInputs(\n                                bytes4(command), // selector\n                                indices\n                            )\n                            : state[\n                                uint8(bytes1(indices)) &\n                                CommandBuilder.IDX_VALUE_MASK\n                            ]\n                    );\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_VALUECALL) {\n                uint256 callEth;\n                bytes memory v = state[uint8(bytes1(indices))];\n                assembly {\n                    callEth := mload(add(v, 0x20))\n                }\n                (success, outData) = address(uint160(uint256(command))).call{ // target\n                    value: callEth\n                }(\n                    // inputs\n                    flags & FLAG_DATA == 0\n                        ? state.buildInputs(\n                            bytes4(command), // selector\n                            indices << 8 // skip value input\n                        )\n                        : state[\n                            uint8(\n                                bytes1(indices << 8) // first byte after value input\n                            ) & CommandBuilder.IDX_VALUE_MASK\n                        ]\n                );\n            } else {\n                revert(\"Invalid calltype\");\n            }\n\n            if (!success) {\n                if (outData.length > 0) {\n                    assembly {\n                        outData := add(outData, 68)\n                    }\n                }\n                revert ExecutionFailed({\n                    command_index: flags & FLAG_EXTENDED_COMMAND == 0\n                        ? i\n                        : i - 1,\n                    target: address(uint160(uint256(command))),\n                    message: outData.length > 0 ? string(outData) : \"Unknown\"\n                });\n            }\n\n            if (flags & FLAG_TUPLE_RETURN != 0) {\n                state.writeTuple(bytes1(command << 88), outData);\n            } else {\n                state = state.writeOutputs(bytes1(command << 88), outData);\n            }\n        }\n        return state;\n    }\n\n    function _uncheckedIncrement(uint256 i) private pure returns (uint256) {\n        unchecked {\n            ++i;\n        }\n        return i;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/access/AccessController.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.16;\n\nimport \"./ACL.sol\";\nimport \"./Roles.sol\";\n\n// @notice The OWNER_ROLE must be set in the importing contract's constructor or initialize function\nabstract contract AccessController is ACL, Roles {\n    using StorageAPI for bytes32;\n\n    event PermissionSet(bytes32 role, address account, bool permission);\n\n    error UnsafeSetting();\n\n    // @notice Sets user permission over a role\n    // @param role The bytes32 value of the role\n    // @param account The address of the account\n    // @param permission The permission status\n    function setPermission(\n        bytes32 role,\n        address account,\n        bool permission\n    ) external isPermitted(OWNER_ROLE) {\n        if (role == OWNER_ROLE && account == msg.sender && permission == false)\n            revert UnsafeSetting();\n        _setPermission(role, account, permission);\n    }\n\n    // @notice Internal function to set user permission over a role\n    // @param role The bytes32 value of the role\n    // @param account The address of the account\n    // @param permission The permission status\n    function _setPermission(\n        bytes32 role,\n        address account,\n        bool permission\n    ) internal {\n        bytes32 key = _getKey(role, account);\n        key.setBool(permission);\n        emit PermissionSet(role, account, permission);\n    }\n}\n"
    },
    "contracts/access/ACL.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.16;\n\nimport \"../libraries/StorageAPI.sol\";\n\nabstract contract ACL {\n    using StorageAPI for bytes32;\n\n    error NotPermitted();\n\n    modifier isPermitted(bytes32 role) {\n        bool permitted = _getPermission(role, msg.sender); // TODO: support GSN/Account abstraction\n        if (!permitted) revert NotPermitted();\n        _;\n    }\n\n    // @notice Gets user permission for a role\n    // @param role The bytes32 value of the role\n    // @param account The address of the account\n    // @return The permission status\n    function getPermission(\n        bytes32 role,\n        address account\n    ) external view returns (bool) {\n        return _getPermission(role, account);\n    }\n\n    // @notice Internal function to get user permission for a role\n    // @param role The bytes32 value of the role\n    // @param account The address of the account\n    // @return The permission status\n    function _getPermission(\n        bytes32 role,\n        address account\n    ) internal view returns (bool) {\n        bytes32 key = _getKey(role, account);\n        return key.getBool();\n    }\n\n    // @notice Internal function to get the key for the storage slot\n    // @param role The bytes32 value of the role\n    // @param account The address of the account\n    // @return The bytes32 storage slot\n    function _getKey(\n        bytes32 role,\n        address account\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(role, account));\n    }\n}\n"
    },
    "contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"../libraries/StorageAPI.sol\";\n\n// @notice The OWNER slot must be set in the importing contract's constructor or initialize function\nabstract contract Ownable {\n    using StorageAPI for bytes32;\n\n    // Using same slot generation technique as eip-1967 -- https://eips.ethereum.org/EIPS/eip-1967\n    bytes32 internal constant OWNER = bytes32(uint256(keccak256(\"enso.access.owner\")) - 1);\n    bytes32 internal constant PENDING_OWNER = bytes32(uint256(keccak256(\"enso.access.pendingOwner\")) - 1);\n\n    event OwnershipTransferred(address previousOwner, address newOwner);\n    event OwnershipTransferStarted(address previousOwner, address newOwner);\n\n    error NotOwner();\n    error NotPermitted();\n    error InvalidAccount();\n\n    modifier onlyOwner {\n        if (msg.sender != OWNER.getAddress()) revert NotOwner();\n        _;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        if (newOwner == address(0)) revert InvalidAccount();\n        address currentOwner = OWNER.getAddress();\n        if (newOwner == currentOwner) revert InvalidAccount();\n        PENDING_OWNER.setAddress(newOwner);\n        emit OwnershipTransferStarted(currentOwner, newOwner);\n    }\n\n    function acceptOwnership() external {\n        if (msg.sender != PENDING_OWNER.getAddress()) revert NotPermitted();\n        PENDING_OWNER.setAddress(address(0));\n        address previousOwner = OWNER.getAddress();\n        OWNER.setAddress(msg.sender);\n        emit OwnershipTransferred(previousOwner, msg.sender);\n    }\n\n    function owner() external view returns (address) {\n        return OWNER.getAddress();\n    }\n}\n"
    },
    "contracts/access/Roles.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.16;\n\nabstract contract Roles {\n    bytes32 public constant OWNER_ROLE = keccak256(\"enso.access.roles.owner\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"enso.access.roles.executor\");\n}\n"
    },
    "contracts/EnsoBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IBeacon.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"./interfaces/IUUPS.sol\";\n\ncontract EnsoBeacon is IBeacon {\n    address public admin;\n    address public delegate;\n    address public factory;\n    address public coreImplementation;\n    address public fallbackImplementation;\n\n    address public pendingAdmin;\n    address public pendingDelegate;\n    address public pendingCoreImplementation;\n    address public pendingFactoryImplementation;\n    bytes public pendingFactoryUpgradeData;\n\n    uint256 public delay;\n    uint256 public upgradeTimestamp;\n\n    event CoreUpgraded(address previousImplementation, address newImplementation);\n    event FallbackUpgraded(address previousImplementation, address newImplementation);\n    event EmergencyUpgrade();\n    event AdministrationTransferred(address previousAdmin, address newAdmin);\n    event AdministrationTransferStarted(address previousAdmin, address newAdmin);\n    event DelegationTransferred(address previousDelegate, address newDelegate);\n    event DelegationTransferStarted(address previousDelegate, address newDelegate);\n    event Factory(address newFactory);\n    event Delay(uint256 newDelay);\n\n    error InvalidImplementation();\n    error InvalidAccount();\n    error NotPermitted();\n    error NoPendingUpgrade();\n    error Wait();\n\n    modifier onlyAdmin {\n        if (msg.sender != admin) revert NotPermitted();\n        _;\n    }\n\n    modifier onlyDelegate {\n        if (msg.sender != delegate) revert NotPermitted();\n        _;\n    }\n\n    constructor(\n        address coreImplementation_,\n        address fallbackImplementation_\n    ) {\n        admin = msg.sender;\n        delegate = msg.sender;\n        coreImplementation = coreImplementation_;\n        fallbackImplementation = fallbackImplementation_;\n    }\n\n    // @notice The current core implementation\n    // @dev Called by proxy contracts to get the implementation address\n    function implementation() external view override returns (address) {\n        return coreImplementation;\n    }\n\n    // @notice Switch from the core implementation to the fallback implemenation\n    function emergencyUpgrade() external onlyDelegate {\n        _upgradeCore(fallbackImplementation);\n        emit EmergencyUpgrade();\n    }\n\n    // @notice Finalize the new core implementation\n    function finalizeUpgrade() external {\n        // Load timestamp and check\n        uint256 timestamp = upgradeTimestamp;\n        if (timestamp == 0) revert NoPendingUpgrade();\n        if (timestamp + delay > block.timestamp) revert Wait();\n        delete upgradeTimestamp;\n        // Load implementation data and check\n        address newImplementation = pendingCoreImplementation;\n        address factoryImplementation = pendingFactoryImplementation;\n        bytes memory data = pendingFactoryUpgradeData;\n        if (newImplementation == address(0)) revert InvalidImplementation(); // sanity check\n        delete pendingCoreImplementation;\n        delete pendingFactoryImplementation;\n        delete pendingFactoryUpgradeData;\n        // Upgrade\n        _upgradeCore(newImplementation);\n        if (factoryImplementation != address(0)) _upgradeFactory(factoryImplementation, data);\n    }\n\n    // @notice Initialize an upgrade to a new core implementation\n    // @param newImplementation The address of the new core implementation\n    // @param factoryImplementation Optionally include a new factory implementation to upgrade the factory simultaneously. Pass zero address if no upgrade is needed\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if factory is not being upgraded or no additional call needs to be made\n    function upgradeCore(\n        address newImplementation,\n        address factoryImplementation,\n        bytes memory data\n    ) external onlyAdmin {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        upgradeTimestamp = block.timestamp;\n        pendingCoreImplementation = newImplementation;\n        // If the following is null data, at least we ensure that any old pending values are overwritten\n        pendingFactoryImplementation = factoryImplementation;\n        pendingFactoryUpgradeData = data;\n    }\n\n    // @notice Upgrade the fallback implementation\n    // @param newImplementation The address of the new fallback implementation\n    function upgradeFallback(address newImplementation) external onlyAdmin {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        if (newImplementation == fallbackImplementation) revert InvalidImplementation();\n        address previousImplementation = fallbackImplementation;\n        fallbackImplementation = newImplementation;\n        emit FallbackUpgraded(previousImplementation, newImplementation);\n    }\n\n    // @notice Upgrade the factory implementation\n    // @param newImplementation The address of the new factory implementation\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if no additional call needs to be made\n    function upgradeFactory(address newImplementation, bytes memory data) external onlyAdmin {\n        _upgradeFactory(newImplementation, data);\n    }\n\n    // @notice Initiate transfer of the admin role\n    // @notice newAdmin The address of the new admin\n    function transferAdministration(address newAdmin) external onlyAdmin {\n        if (newAdmin == address(0)) revert InvalidAccount();\n        if (newAdmin == admin) revert InvalidAccount();\n        pendingAdmin = newAdmin;\n        emit AdministrationTransferStarted(admin, newAdmin);\n    }\n\n    // @notice Accept new admin role\n    // @dev Only the pending admin can call this function\n    function acceptAdministration() external {\n        if (msg.sender != pendingAdmin) revert NotPermitted();\n        delete pendingAdmin;\n        address previousAdmin = admin;\n        admin = msg.sender;\n        emit AdministrationTransferred(previousAdmin, msg.sender);\n    }\n\n    // @notice Renounce admin role. No upgrades can be done if this function is called.\n    // @dev This function renounes both the admin and the delegate roles.\n    function renounceAdministration() external onlyAdmin {\n        address previousAdmin = admin;\n        address previousDelegate = delegate;\n        delete admin;\n        delete delegate;\n        delete pendingAdmin;\n        delete pendingDelegate;\n        emit AdministrationTransferred(previousAdmin, address(0));\n        emit DelegationTransferred(previousDelegate, address(0));\n    }\n\n    // @notice Initiate transfer of the delegate role\n    // @notice newDelegate The address of the new delegate\n    function transferDelegation(address newDelegate) external onlyAdmin {\n        if (newDelegate == address(0)) revert InvalidAccount();\n        if (newDelegate == delegate) revert InvalidAccount();\n        pendingDelegate = newDelegate;\n        emit DelegationTransferStarted(delegate, newDelegate);\n    }\n\n    // @notice Accept new delegate role\n    // @dev Only the pending delegate can call this function\n    function acceptDelegation() external {\n        if (msg.sender != pendingDelegate) revert NotPermitted();\n        delete pendingDelegate;\n        address previousDelegate = delegate;\n        delegate = msg.sender;\n        emit DelegationTransferred(previousDelegate, msg.sender);\n    }\n\n    // @notice Renounce delegate role. Emergency upgrades cannot happen while this role remain unfilled.\n    // @dev The admin can alway give this role to another address with the transferDelegation function\n    function renounceDelegation() external onlyDelegate {\n        address previousDelegate = delegate;\n        delete delegate;\n        emit DelegationTransferred(previousDelegate, address(0));\n    }\n\n    // @notice Transfer ownership of a contract that is owned by this contract\n    // @param ownable The address of the contract that is getting it's ownership transferred\n    // @param newOwner The address of the new owner\n    function transferOwnership(address ownable, address newOwner) external onlyAdmin {\n        IOwnable(ownable).transferOwnership(newOwner);\n    }\n\n    // @notice Accept ownership of another contract by this contract\n    // @param ownable The address of the contract that is getting it's ownership transferred\n    function acceptOwnership(address ownable) external onlyAdmin {\n        IOwnable(ownable).acceptOwnership();\n    }\n\n    // @notice Set the current factory address in state\n    // @param newFactory The address of the new factory\n    function setFactory(address newFactory) external onlyAdmin {\n        factory = newFactory;\n        emit Factory(newFactory);\n    }\n\n    // @notice Update the delay between in initiating an upgrade and finalizing the upgrade\n    // @param newDelay The new delay in seconds\n    function setDelay(uint256 newDelay) external onlyAdmin {\n        delay = newDelay;\n        emit Delay(newDelay);\n    }\n\n    // @notice Internal function for setting the new core implementation\n    // @param newImplementation The address of the new implementation\n    function _upgradeCore(address newImplementation) internal {\n        if (newImplementation == address(0)) revert InvalidImplementation();\n        //if (newImplementation == coreImplementation) revert InvalidImplementation();\n        address previousImplementation = coreImplementation;\n        coreImplementation = newImplementation;\n        emit CoreUpgraded(previousImplementation, newImplementation);\n    }\n\n    // @notice Internal function for upgrading the factory implementation\n    // @param newImplementation The address of the new factory implementation\n    // @param data Calldata for upgrading the new factory. Pass zero bytes if no additional call needs to be made\n    function _upgradeFactory(address newImplementation, bytes memory data) internal {\n        if (data.length > 0) {\n            IUUPS(factory).upgradeToAndCall(newImplementation, data);\n        } else {\n            IUUPS(factory).upgradeTo(newImplementation);\n        }\n    }\n}\n"
    },
    "contracts/EnsoWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@ensofinance/weiroll/contracts/VM.sol\";\nimport \"./access/AccessController.sol\";\nimport \"./wallet/ERC1271.sol\";\nimport \"./wallet/MinimalWallet.sol\";\nimport \"./interfaces/IEnsoWallet.sol\";\n\ncontract EnsoWallet is IEnsoWallet, VM, AccessController, ERC1271, MinimalWallet {\n    using StorageAPI for bytes32;\n\n    // Using same slot generation technique as eip-1967 -- https://eips.ethereum.org/EIPS/eip-1967\n    bytes32 internal constant SALT = bytes32(uint256(keccak256(\"enso.wallet.salt\")) - 1);\n\n    error AlreadyInit();\n\n    // @notice Initialize wallet by setting state and permissions\n    // @dev A wallet is considered initialized if the SALT is set in state. Subsequent calls to this function will fail.\n    // @param owner The address of the wallet owner\n    // @param salt The salt used to deploy the proxy that uses this contract as it's implementation\n    // @param shortcutId The bytes32 value representing a shortcut\n    // @param commands The optional commands for executing a shortcut\n    // @param state The optional state for executing a shortcut\n    function initialize(\n        address owner,\n        bytes32 salt,\n        bytes32 shortcutId,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) external override payable {\n        if (SALT.getBytes32() != bytes32(0)) revert AlreadyInit();\n        SALT.setBytes32(salt);\n        _setPermission(OWNER_ROLE, owner, true);\n        _setPermission(EXECUTOR_ROLE, owner, true);\n        if (commands.length != 0) {\n            _executeShortcut(shortcutId, commands, state);\n        }\n    }\n\n    // @notice A function to execute an arbitrary call on another contract\n    // @param target The address of the target contract\n    // @param value The ether value that is to be sent with the call\n    // @param data The call data to be sent to the target\n    function execute(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) external payable isPermitted(EXECUTOR_ROLE) returns (bool success) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(gas(), target, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    // @notice Execute a shortcut from this contract\n    // @param shortcutId The bytes32 value representing a shortcut\n    // @param commands An array of bytes32 values that encode calls\n    // @param state An array of bytes that are used to generate call data for each command\n    function executeShortcut(\n        bytes32 shortcutId,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    )\n        external\n        payable\n        isPermitted(EXECUTOR_ROLE)\n        returns (bytes[] memory returnData)\n    {\n        returnData = _executeShortcut(shortcutId, commands, state);\n    }\n\n    // @notice Internal function to execute a shortcut from this contract\n    // @param shortcutId The bytes32 value representing a shortcut\n    // @param commands An array of bytes32 values that encode calls\n    // @param state An array of bytes that are used to generate call data for each command\n    function _executeShortcut(\n        bytes32 shortcutId,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    )\n        internal\n        returns (bytes[] memory returnData)\n    {\n        (shortcutId); // ShortcutId just needs to be retrieved from call data, can support events in future upgrade\n        returnData = _execute(commands, state);\n    }\n\n\n    // @notice Internal function for checking the ERC-1271 signer\n    // @param signer The address that signed a message\n    function _checkSigner(address signer) internal view override returns (bool) {\n        return _getPermission(OWNER_ROLE, signer);\n    }\n}\n"
    },
    "contracts/EnsoWalletFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"./libraries/BeaconClones.sol\";\nimport \"./access/Ownable.sol\";\nimport \"./interfaces/IEnsoWallet.sol\";\n\ncontract EnsoWalletFactory is Ownable, UUPSUpgradeable {\n    using StorageAPI for bytes32;\n    using BeaconClones for address;\n\n    address public immutable ensoBeacon;\n\n    event Deployed(IEnsoWallet instance, string label);\n\n    error AlreadyInit();\n    error NoLabel();\n\n    constructor(address ensoBeacon_) {\n        ensoBeacon = ensoBeacon_;\n    }\n\n    // @notice A function to initialize state on the proxy the delegates to this contract\n    function initialize() external {\n        if (OWNER.getAddress() != address(0)) revert AlreadyInit();\n        OWNER.setAddress(msg.sender);\n    }\n\n    // @notice Deploy a wallet using the msg.sender as the salt\n    // @param shortcutId The bytes32 value representing a shortcut\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function deploy(\n        bytes32 shortcutId,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) public payable returns (IEnsoWallet) {\n        bytes32 salt = bytes32(uint256(uint160(msg.sender)));\n        return _deploy(salt, \"\", shortcutId, commands, state);\n    }\n\n    // @notice Deploy a wallet using a hash of the msg.sender and a label as the salt\n    // @param label The label to indentify deployment\n    // @param shortcutId The bytes32 value representing a shortcut\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function deployCustom(\n        string memory label,\n        bytes32 shortcutId,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) public payable returns (IEnsoWallet) {\n        if (bytes(label).length == 0) revert NoLabel();\n        bytes32 salt = _customSalt(msg.sender, label);\n        return _deploy(salt, label, shortcutId, commands, state);\n    }\n\n    // @notice Get the deployment address for the msg.sender\n    function getAddress() public view returns (address payable) {\n        return getUserAddress(msg.sender);\n    }\n\n    // @notice Get the deployment address for the user\n    // @param user The address of the user that is used to determine the deployment address\n    function getUserAddress(address user) public view returns (address payable) {\n        bytes32 salt = bytes32(uint256(uint160(user)));\n        return _predictDeterministicAddress(salt);\n    }\n\n    // @notice Get the deployment address for a user and label\n    // @param user The address of the user that is used to determine the deployment address\n    // @param label The label that is used to determine the deployment address\n    function getCustomAddress(address user, string memory label) external view returns (address payable) {\n        if (bytes(label).length == 0) revert NoLabel();\n        bytes32 salt = _customSalt(user, label);\n        return _predictDeterministicAddress(salt);\n    }\n\n    // @notice The internal function for deploying a new wallet\n    // @param salt The salt for deploy the address deterministically\n    // @param label The label to indentify deployment in the emitted event\n    // @param shortcutId The bytes32 value representing a shortcut\n    // @param commands The optional commands for executing a shortcut after deployment\n    // @param state The optional state for executing a shortcut after deployment\n    function _deploy(\n        bytes32 salt,\n        string memory label,\n        bytes32 shortcutId,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) internal returns (IEnsoWallet instance) {\n        instance = IEnsoWallet(payable(ensoBeacon.cloneDeterministic(salt)));\n        instance.initialize{ value: msg.value }(msg.sender, salt, shortcutId, commands, state);\n        emit Deployed(instance, label);\n    }\n\n    // @notice Internal function to generate a custom salt using a user address and label\n    // @param user The address of the user\n    // @param label The label to identify the deployment\n    function _customSalt(address user, string memory label) internal pure returns (bytes32) {\n        return keccak256(abi.encode(user, label));\n    }\n\n    // @notice Internal function to derive the deployment address from a salt\n    // @param salt The bytes32 salt to generate the deployment address\n    function _predictDeterministicAddress(bytes32 salt) internal view returns (address payable) {\n        return payable(ensoBeacon.predictDeterministicAddress(\n            salt,\n            address(this)\n        ));\n    }\n\n    // @notice Internal function to support UUPS upgrades of the implementing proxy\n    // @notice newImplementation Address of the new implementation\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        if (msg.sender != OWNER.getAddress()) revert NotOwner();\n    }\n}\n"
    },
    "contracts/interfaces/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IBeacon {\n    function implementation() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IEnsoWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IEnsoWallet {\n    function initialize(\n        address owner,\n        bytes32 salt,\n        bytes32 shortcutId,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IERC1271 {\n    function isValidSignature(\n        bytes32 _hash,\n        bytes calldata _signature\n    ) external view returns (bytes4 magicValue);\n\n    function isValidSignature(\n       bytes calldata _message,\n       bytes calldata _signature\n    ) external view returns (bytes4 magicValue);\n}\n"
    },
    "contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IOwnable {\n    function transferOwnership(address newOwner) external;\n\n    function acceptOwnership() external;\n}\n"
    },
    "contracts/interfaces/IUUPS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IUUPS {\n    function upgradeTo(address newImplementation) external;\n\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external;\n}\n"
    },
    "contracts/libraries/BeaconClones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n// Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol\n\npragma solidity ^0.8.16;\n\nlibrary BeaconClones {\n    /**\n     * @dev Deploys and returns the address of a clone that gets an implementation\n     *      from the `beacon` and mimics its behaviour.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `beacon` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address beacon, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x6080604052348015600f57600080fd5b5060a88061001e6000396000f3fe6080)\n            mstore(add(ptr, 0x20), 0x6040526040517f5c60da1b000000000000000000000000000000000000000000)\n            mstore(add(ptr, 0x40), 0x0000000000000081526000600160208260048573000000000000000000000000)\n            mstore(add(ptr, 0x54), shl(0x60, beacon))\n            mstore(add(ptr, 0x68), 0x5afa0360705780513682833781823684845af490503d82833e808015606c573d)\n            mstore(add(ptr, 0x88), 0x83f35b3d83fd5b00fea264697066735822122002f8a2f5acabeb1d754972351e)\n            mstore(add(ptr, 0xa8), 0xc784958a7f99e64f368c267a38bb375594c03c64736f6c634300081000330000)\n            instance := create2(0, ptr, 0xc6, salt)\n        }\n        require(instance != address(0), \"create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x6080604052348015600f57600080fd5b5060a88061001e6000396000f3fe6080)\n            mstore(add(ptr, 0x20), 0x6040526040517f5c60da1b000000000000000000000000000000000000000000)\n            mstore(add(ptr, 0x40), 0x0000000000000081526000600160208260048573000000000000000000000000)\n            mstore(add(ptr, 0x54), shl(0x60, beacon))\n            mstore(add(ptr, 0x68), 0x5afa0360705780513682833781823684845af490503d82833e808015606c573d)\n            mstore(add(ptr, 0x88), 0x83f35b3d83fd5b00fea264697066735822122002f8a2f5acabeb1d754972351e)\n            mstore(add(ptr, 0xa8), 0xc784958a7f99e64f368c267a38bb375594c03c64736f6c63430008100033ff00)\n            mstore(add(ptr, 0xc7), shl(0x60, deployer))\n            mstore(add(ptr, 0xdb), salt)\n            mstore(add(ptr, 0xfb), keccak256(ptr, 0xc6))\n            predicted := keccak256(add(ptr, 0xc6), 0x55)\n        }\n    }\n}\n"
    },
    "contracts/libraries/StorageAPI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nlibrary StorageAPI {\n    function setBytes(bytes32 key, bytes memory data) internal {\n        bytes32 slot = keccak256(abi.encodePacked(key));\n        assembly {\n            let length := mload(data)\n            switch gt(length, 0x1F)\n            case 0x00 {\n                sstore(key, or(mload(add(data, 0x20)), mul(length, 2)))\n            }\n            case 0x01 {\n                sstore(key, add(mul(length, 2), 1))\n                for {let i:= 0} lt(mul(i, 0x20), length) {i := add(i, 0x01)} {\n                    sstore(add(slot, i), mload(add(data, mul(add(i, 1), 0x20))))\n                }\n            }\n        }\n    }\n\n    function setBytes32(bytes32 key, bytes32 val) internal {\n        assembly {\n            sstore(key, val)\n        }\n    }\n\n    function setAddress(bytes32 key, address a) internal {\n        assembly {\n            sstore(key, a)\n        }\n    }\n\n    function setUint256(bytes32 key, uint256 val) internal {\n        assembly {\n            sstore(key, val)\n        }\n    }\n\n    function setInt256(bytes32 key, int256 val) internal {\n        assembly {\n            sstore(key, val)\n        }\n    }\n\n    function setBool(bytes32 key, bool val) internal {\n        assembly {\n            sstore(key, val)\n        }\n    }\n\n    function getBytes(bytes32 key) internal view returns (bytes memory data) {\n        bytes32 slot = keccak256(abi.encodePacked(key));\n        assembly {\n            let length := sload(key)\n            switch and(length, 0x01)\n            case 0x00 {\n                let decodedLength := div(and(length, 0xFF), 2)\n                mstore(data, decodedLength)\n                mstore(add(data, 0x20), and(length, not(0xFF)))\n                mstore(0x40, add(data, 0x40))\n            }\n            case 0x01 {\n                let decodedLength := div(length, 2)\n                let i := 0\n                mstore(data, decodedLength)\n                for {} lt(mul(i, 0x20), decodedLength) {i := add(i, 0x01)} {\n                    mstore(add(add(data, 0x20), mul(i, 0x20)), sload(add(slot, i)))\n                }\n                mstore(0x40, add(data, add(0x20, mul(i, 0x20))))\n            }\n        }\n    }\n\n    function getBytes32(bytes32 key) internal view returns (bytes32 val) {\n        assembly {\n            val := sload(key)\n        }\n    }\n\n    function getAddress(bytes32 key) internal view returns (address a) {\n        assembly {\n            a := sload(key)\n        }\n    }\n\n    function getUint256(bytes32 key) internal view returns (uint256 val) {\n        assembly {\n            val := sload(key)\n        }\n    }\n\n    function getInt256(bytes32 key) internal view returns (int256 val) {\n        assembly {\n            val := sload(key)\n        }\n    }\n\n    function getBool(bytes32 key) internal view returns (bool val) {\n        assembly {\n            val := sload(key)\n        }\n    }\n}\n"
    },
    "contracts/test/ApprovableMinimalWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"../wallet/MinimalWallet.sol\";\n\ncontract ApprovableMinimalWallet is MinimalWallet {\n    function approveERC20(IERC20 erc20, address spender) external {\n        erc20.approve(spender, type(uint256).max);\n    }\n\n    function approveERC721(IERC721 erc721, address spender) external {\n        erc721.setApprovalForAll(spender, true);\n    }\n\n    function approveERC1155(IERC1155 erc1155, address spender) external {\n        erc1155.setApprovalForAll(spender, true);\n    }\n}\n"
    },
    "contracts/test/DestructEnsoWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"../access/AccessController.sol\";\nimport \"./ApprovableMinimalWallet.sol\";\n\ncontract Destroyer {\n    function kill() public returns (bytes[] memory data) {\n        selfdestruct(payable(msg.sender));\n        return data;\n    }\n}\n\ncontract DestructEnsoWallet is AccessController, ApprovableMinimalWallet {\n    using StorageAPI for bytes32;\n\n    // Using same slot generation technique as eip-1967 -- https://eips.ethereum.org/EIPS/eip-1967\n    bytes32 internal constant SALT = bytes32(uint256(keccak256(\"enso.wallet.salt\")) - 1);\n\n    event DelegateCallReturn(bool success, bytes ret);\n\n    error AlreadyInit();\n\n    function initialize(\n        address owner,\n        bytes32 salt,\n        bytes32 shortcutId,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) external payable {\n        if (SALT.getBytes32() != bytes32(0)) revert AlreadyInit();\n        SALT.setBytes32(salt);\n        _setPermission(OWNER_ROLE, owner, true);\n        _setPermission(EXECUTOR_ROLE, owner, true);\n        if (commands.length != 0) {\n            executeShortcut(shortcutId, commands, state);\n        }\n    }\n\n    function executeShortcut(bytes32 shortcutId, bytes32[] calldata commands, bytes[] calldata state) public isPermitted(EXECUTOR_ROLE) returns (bytes[] memory data) {\n        (shortcutId);\n        Destroyer destroyer = new Destroyer();\n        (bool success, bytes memory ret) = address(destroyer).delegatecall(\n            abi.encodeWithSelector(destroyer.kill.selector, commands, state)\n        );\n        emit DelegateCallReturn(success, ret);\n        return data;\n    }\n}\n"
    },
    "contracts/test/DumbEnsoWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"../access/AccessController.sol\";\nimport \"./ApprovableMinimalWallet.sol\";\n\ncontract DumbEnsoWallet is AccessController, ApprovableMinimalWallet {\n    using StorageAPI for bytes32;\n\n    // Using same slot generation technique as eip-1967 -- https://eips.ethereum.org/EIPS/eip-1967\n    bytes32 internal constant SALT = bytes32(uint256(keccak256(\"enso.wallet.salt\")) - 1);\n\n    event VMData(bytes32[] commands, bytes[] state);\n    event SenderData(address sender, uint256 value);\n\n    error AlreadyInit();\n\n    function initialize(\n        address owner,\n        bytes32 salt,\n        bytes32 shortcutId,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) external payable {\n        (shortcutId);\n        if (SALT.getBytes32() != bytes32(0)) revert AlreadyInit();\n        SALT.setBytes32(salt);\n        _setPermission(OWNER_ROLE, owner, true);\n        _setPermission(EXECUTOR_ROLE, owner, true);\n        if (commands.length != 0) {\n            _execute(commands, state);\n        }\n    }\n\n    function executeShortcut(bytes32 shortcutId, bytes32[] calldata commands, bytes[] calldata state) public payable isPermitted(EXECUTOR_ROLE) returns (bytes[] memory) {\n        (shortcutId);\n        return _execute(commands, state);\n    }\n\n    function _execute(bytes32[] calldata commands, bytes[] memory state) internal returns (bytes[] memory) {\n        emit VMData(commands, state);\n        emit SenderData(msg.sender, msg.value);\n        return state;\n    }\n}\n"
    },
    "contracts/test/MockFactoryUpgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"../EnsoWalletFactory.sol\";\n\ncontract MockFactoryUpgrade is EnsoWalletFactory {\n\n    constructor(address ensoBeacon_) EnsoWalletFactory(ensoBeacon_) {}\n\n    function newFunctionTest() external pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/test/MockWalletUpgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./DumbEnsoWallet.sol\";\n\ncontract MockWalletUpgrade is DumbEnsoWallet {\n    function newFunctionTest() external pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/wallet/ERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../interfaces/IERC1271.sol\";\n\nabstract contract ERC1271 is IERC1271 {\n    using ECDSA for bytes32;\n\n    bytes4 constant internal MAGICVALUE_BYTES = 0x20c13b0b;\n    bytes4 constant internal MAGICVALUE_BYTES32 = 0x1626ba7e;\n    bytes4 constant internal INVALID_SIGNATURE = 0xffffffff;\n\n    // @notice Checks for a valid signature\n    // @param hash A bytes32 hash of a message\n    // @param signature The signed hash of the message\n    function isValidSignature(\n        bytes32 hash,\n        bytes memory signature\n    )\n        public\n        override\n        view\n        returns (bytes4 magicValue)\n    {\n        address signer = hash.recover(signature);\n        magicValue = _checkSigner(signer) ? MAGICVALUE_BYTES32 : INVALID_SIGNATURE;\n    }\n\n    // @notice Checks for a valid signature\n    // @param message The message that has been signed\n    // @param signature The signed hash of the message\n    function isValidSignature(\n        bytes memory message,\n        bytes memory signature\n    )\n        public\n        override\n        view\n        returns (bytes4 magicValue)\n    {\n        address signer = ECDSA.toEthSignedMessageHash(message).recover(signature);\n        magicValue = _checkSigner(signer) ? MAGICVALUE_BYTES : INVALID_SIGNATURE;\n    }\n\n    // @notice Confirm signer is permitted to sign on behalf of contract\n    // @dev Abstract function to implemented by importing contract\n    // @param signer The address of the message signer\n    // @return Bool confirming whether signer is permitted\n    function _checkSigner(address signer) internal view virtual returns (bool);\n}\n"
    },
    "contracts/wallet/MinimalWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"../access/ACL.sol\";\nimport \"../access/Roles.sol\";\n\ncontract MinimalWallet is ACL, Roles, ERC721Holder, ERC1155Holder {\n    using SafeERC20 for IERC20;\n\n    enum Protocol {\n        ETH,\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n\n    struct TransferNote {\n        Protocol protocol;\n        address token;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    struct ApprovalNote {\n        Protocol protocol;\n        address token;\n        address[] operators;\n    }\n\n    error WithdrawFailed();\n    error InvalidArrayLength();\n\n    ////////////////////////////////////////////////////\n    // External functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    // @notice Withdraw an array of assets\n    // @dev Works for ETH, ERC20s, ERC721s, and ERC1155s\n    // @param notes A tuple that contains the protocol id, token address, array of ids and amounts\n    function withdraw(TransferNote[] memory notes) external isPermitted(OWNER_ROLE) {\n        TransferNote memory note;\n        Protocol protocol;\n        uint256[] memory ids;\n        uint256[] memory amounts;\n\n        uint256 length = notes.length;\n        for (uint256 i; i < length; ) {\n            note = notes[i];\n            protocol = note.protocol;\n            if (protocol == Protocol.ETH) {\n                amounts = note.amounts;\n                if (amounts.length != 1) revert InvalidArrayLength();\n                _withdrawETH(amounts[0]);\n            } else if (protocol == Protocol.ERC20) {\n                amounts = note.amounts;\n                if (amounts.length != 1) revert InvalidArrayLength();\n                _withdrawERC20(IERC20(note.token), amounts[0]);\n            } else if (protocol == Protocol.ERC721) {\n                ids = note.ids;\n                _withdrawERC721s(IERC721(note.token), ids);\n            } else if (protocol == Protocol.ERC1155) {\n                ids = note.ids;\n                amounts = note.amounts;\n                _withdrawERC1155s(IERC1155(note.token), ids, amounts);\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Withdraw ETH from this contract to the msg.sender\n    // @param amount The amount of ETH to be withdrawn\n    function withdrawETH(uint256 amount) external isPermitted(OWNER_ROLE) {\n        _withdrawETH(amount);\n    }\n\n    // @notice Withdraw ERC20s\n    // @param erc20s An array of erc20 addresses\n    // @param amounts An array of amounts for each erc20\n    function withdrawERC20s(\n        IERC20[] memory erc20s,\n        uint256[] memory amounts\n    ) external isPermitted(OWNER_ROLE) {\n        uint256 length = erc20s.length;\n        if (amounts.length != length) revert InvalidArrayLength();\n        for (uint256 i; i < length; ) {\n            _withdrawERC20(erc20s[i], amounts[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Withdraw multiple ERC721 ids for a single ERC721 contract\n    // @param erc721 The address of the ERC721 contract\n    // @param ids An array of ids that are to be withdrawn\n    function withdrawERC721s(\n        IERC721 erc721,\n        uint256[] memory ids\n    ) external isPermitted(OWNER_ROLE) {\n        _withdrawERC721s(erc721, ids);\n    }\n\n    // @notice Withdraw multiple ERC1155 ids for a single ERC1155 contract\n    // @param erc1155 The address of the ERC155 contract\n    // @param ids An array of ids that are to be withdrawn\n    // @param amounts An array of amounts per id\n    function withdrawERC1155s(\n        IERC1155 erc1155,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) external isPermitted(OWNER_ROLE) {\n        _withdrawERC1155s(erc1155, ids, amounts);\n    }\n\n    // @notice Revoke approval on an array of assets and operators\n    // @dev Works for ERC20s, ERC721s, and ERC1155s\n    // @param notes A tuple that contains the protocol id, token address, and array of operators\n    function revokeApprovals(ApprovalNote[] memory notes) external isPermitted(OWNER_ROLE) {\n        ApprovalNote memory note;\n        Protocol protocol;\n\n        uint256 length = notes.length;\n        for (uint256 i; i < length; ) {\n            note = notes[i];\n            protocol = note.protocol;\n            if (protocol == Protocol.ERC20) {\n                _revokeERC20Approvals(IERC20(note.token), note.operators);\n            } else if (protocol == Protocol.ERC721) {\n                _revokeERC721Approvals(IERC721(note.token), note.operators);\n            } else if (protocol == Protocol.ERC1155) {\n                _revokeERC1155Approvals(IERC1155(note.token), note.operators);\n            }\n            unchecked { ++i; }\n        }\n    }\n\n    // @notice Revoke approval of an ERC20 for an array of operators\n    // @param erc20 The address of the ERC20 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC20Approvals(\n        IERC20 erc20,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC20Approvals(erc20, operators);\n    }\n\n    // @notice Revoke approval of an ERC721 for an array of operators\n    // @param erc721 The address of the ERC721 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC721Approvals(\n        IERC721 erc721,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC721Approvals(erc721, operators);\n    }\n\n    // @notice Revoke approval of an ERC1155 for an array of operators\n    // @param erc1155 The address of the ERC1155 token\n    // @param operators The array of operators to have approval revoked\n    function revokeERC1155Approvals(\n        IERC1155 erc1155,\n        address[] memory operators\n    ) external isPermitted(OWNER_ROLE) {\n        _revokeERC1155Approvals(erc1155, operators);\n    }\n\n    ////////////////////////////////////////////////////\n    // Internal functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    function _withdrawETH(uint256 amount) internal {\n        (bool success, ) = msg.sender.call{ value : amount }(\"\");\n        if (!success) revert WithdrawFailed();\n    }\n\n    function _withdrawERC20(\n        IERC20 erc20,\n        uint256 amount\n    ) internal {\n        erc20.safeTransfer(msg.sender, amount);\n    }\n\n    function _withdrawERC721s(\n        IERC721 erc721,\n        uint256[] memory ids\n    ) internal {\n        uint256 length = ids.length;\n        for (uint256 i; i < length; ) {\n            erc721.safeTransferFrom(address(this), msg.sender, ids[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    function _withdrawERC1155s(\n        IERC1155 erc1155,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        // safeBatchTransferFrom will validate the array lengths\n        erc1155.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, \"\");\n    }\n\n    function _revokeERC20Approvals(\n        IERC20 erc20,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc20.safeApprove(operators[i], 0);\n            unchecked { ++i; }\n        }\n    }\n\n    function _revokeERC721Approvals(\n        IERC721 erc721,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc721.setApprovalForAll(operators[i], false);\n            unchecked { ++i; }\n        }\n    }\n\n    function _revokeERC1155Approvals(\n        IERC1155 erc1155,\n        address[] memory operators\n    ) internal {\n        uint256 length = operators.length;\n        for (uint256 i; i < length; ) {\n            erc1155.setApprovalForAll(operators[i], false);\n            unchecked { ++i; }\n        }\n    }\n\n    ////////////////////////////////////////////////////\n    // Fallback functions //////////////////////////////\n    ////////////////////////////////////////////////////\n\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 100000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}