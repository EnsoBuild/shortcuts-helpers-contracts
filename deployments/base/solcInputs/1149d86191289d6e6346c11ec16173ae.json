{
  "language": "Solidity",
  "sources": {
    "contracts/DecimalHelpers.sol": {
      "content": "pragma solidity ^0.8.16;\n\n\ncontract DecimalHelpers {\n    uint256 public constant VERSION = 1;\n\n    function decimalString(uint256 number, uint8 decimals, bool isPercent) public pure returns(string memory){\n        if(number == 0){\n            return isPercent ? \"0%\" : \"0\";\n        }\n        \n        uint8 percentBufferOffset = isPercent ? 1 : 0;\n        uint256 tenPowDecimals = 10 ** decimals;\n\n        uint256 temp = number;\n        uint8 digits;\n        uint8 numSigfigs;\n        while (temp != 0) {\n            if (numSigfigs > 0) {\n                // count all digits preceding least significant figure\n                numSigfigs++;\n            } else if (temp % 10 != 0) {\n                numSigfigs++;\n            }\n            digits++;\n            temp /= 10;\n        }\n\n        DecimalStringParams memory params;\n        params.isPercent = isPercent;\n        if((digits - numSigfigs) >= decimals) {\n            // no decimals, ensure we preserve all trailing zeros\n            params.sigfigs = number / tenPowDecimals;\n            params.sigfigIndex = digits - decimals;\n            params.bufferLength = params.sigfigIndex + percentBufferOffset;\n        } else {\n            // chop all trailing zeros for numbers with decimals\n            params.sigfigs = number / (10 ** (digits - numSigfigs));\n            if(tenPowDecimals > number){\n                // number is less than one\n                // in this case, there may be leading zeros after the decimal place \n                // that need to be added\n\n                // offset leading zeros by two to account for leading '0.'\n                params.zerosStartIndex = 2;\n                params.zerosEndIndex = decimals - digits + 2;\n                params.sigfigIndex = numSigfigs + params.zerosEndIndex;\n                params.bufferLength = params.sigfigIndex + percentBufferOffset;\n                params.isLessThanOne = true;\n            } else {\n                // In this case, there are digits before and\n                // after the decimal place\n                params.sigfigIndex = numSigfigs + 1;\n                params.decimalIndex = digits - decimals + 1;\n            }\n        }\n        params.bufferLength = params.sigfigIndex + percentBufferOffset;\n        return generateDecimalString(params);\n    }\n\n    // With modifications, From https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/NFTDescriptor.sol#L189-L231\n\n    struct DecimalStringParams {\n        // significant figures of decimal\n        uint256 sigfigs;\n        // length of decimal string\n        uint8 bufferLength;\n        // ending index for significant figures (funtion works backwards when copying sigfigs)\n        uint8 sigfigIndex;\n        // index of decimal place (0 if no decimal)\n        uint8 decimalIndex;\n        // start index for trailing/leading 0's for very small/large numbers\n        uint8 zerosStartIndex;\n        // end index for trailing/leading 0's for very small/large numbers\n        uint8 zerosEndIndex;\n        // true if decimal number is less than one\n        bool isLessThanOne;\n        // true if string should include \"%\"\n        bool isPercent;\n    }\n\n    function generateDecimalString(DecimalStringParams memory params) private pure returns (string memory) {\n        bytes memory buffer = new bytes(params.bufferLength);\n        if (params.isPercent) {\n            buffer[buffer.length - 1] = '%';\n        }\n        if (params.isLessThanOne) {\n            buffer[0] = '0';\n            buffer[1] = '.';\n        }\n\n        // add leading/trailing 0's\n        for (uint256 zerosCursor = params.zerosStartIndex; zerosCursor < params.zerosEndIndex; zerosCursor++) {\n            buffer[zerosCursor] = bytes1(uint8(48));\n        }\n        // add sigfigs\n        while (params.sigfigs > 0) {\n            if (params.decimalIndex > 0 && params.sigfigIndex == params.decimalIndex) {\n                buffer[--params.sigfigIndex] = '.';\n            }\n            buffer[--params.sigfigIndex] = bytes1(uint8(uint256(48) + (params.sigfigs % 10)));\n            params.sigfigs /= 10;\n        }\n        return string(buffer);\n    }\n}"
    },
    "contracts/EnsoShortcutsHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @dev SignedMathHelpers contract is recommended to use only in Shortcuts passed to EnsoWallet.\n *\n * This contract functions allow to dynamically get the data during Shortcut transaction execution\n * that usually would be read between transactions\n */\ncontract EnsoShortcutsHelpers {\n    uint256 public constant VERSION = 3;\n\n    /**\n     * @dev Returns the ether balance of given `balanceAddress`.\n     */\n    function getBalance(address balanceAddress) external view returns (uint256 balance) {\n        return address(balanceAddress).balance;\n    }\n\n    /**\n     * @dev Returns the current block timestamp.\n     */\n    function getBlockTimestamp() external view returns (uint256 timestamp) {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Reverts depending on a truth condition\n     */\n    function check(bool condition) external pure {\n        if (!condition) revert(\"Condition not met\");\n    }\n\n    /**\n     * @dev Returns a value depending on a truth condition\n     */\n    function toggle(bool condition, uint256 a, uint256 b) external pure returns (uint256) {\n        if (condition) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    /**\n     * @dev Returns the inverse bool\n     */\n    function not(bool condition) external pure returns (bool) {\n        return !condition;\n    }\n\n    /**\n     * @dev Returns bool for a == b\n     */\n    function isEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return a == b;\n    }\n\n    /**\n     * @dev Returns bool for a < b\n     */\n    function isLessThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a < b;\n    }\n\n    /**\n     * @dev Returns bool for a <= b\n     */\n    function isEqualOrLessThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a <= b;\n    }\n\n    /**\n     * @dev Returns bool for a > b\n     */\n    function isGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a > b;\n    }\n\n    /**\n     * @dev Returns bool for a >= b\n     */\n    function isEqualOrGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\n        return a >= b;\n    }\n\n    /**\n     * @dev Returns bool for a == b\n     */\n    function isAddressEqual(address a, address b) external pure returns (bool) {\n        return a == b;\n    }\n\n    /**\n     * @dev Returns `input` bytes as string.\n     */\n    function bytesToString(bytes calldata input) external pure returns (string memory) {\n        return string(abi.encodePacked(input));\n    }\n\n    /**\n     * @dev Returns `input` bytes as uint256.\n     */\n    function bytesToUint256(bytes calldata input) external pure returns (uint256) {\n        require(input.length == 32, \"EnsoShortcutsHelpers: input length is not 32 bytes\");\n        return uint256(bytes32(input));\n    }\n\n    /**\n     * @dev Returns `input` bytes as bytes32.\n     */\n    function bytesToBytes32(bytes calldata input) external pure returns (bytes32) {\n        return bytes32(input);\n    }\n\n    /**\n     * @dev Returns `input` bytes32 as uint256.\n     */\n    function bytes32ToUint256(bytes32 input) external pure returns (uint256) {\n        return uint256(input);\n    }\n\n    /**\n     * @dev Returns `input` bytes32 as address.\n     */\n    function bytes32ToAddress(bytes32 input) external pure returns (address) {\n        return address(uint160(uint256(input)));\n    }\n\n    /**\n     * @dev Returns uint256 `value` as int256.\n     */\n    function uint256ToInt256(uint256 value) public pure returns (int256) {\n        require(value <= uint256(type(int256).max), \"Value does not fit in an int256\");\n        return int256(value);\n    }\n\n    /**\n     * @dev Returns int256 `value` as uint256.\n     */\n    function int256ToUint256(int256 value) public pure returns (uint256) {\n        require(value >= 0, \"Value must be positive\");\n        return uint256(value);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}